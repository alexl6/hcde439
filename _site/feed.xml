<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.1">Jekyll</generator><link href="http://localhost:4000/hcde439/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/hcde439/" rel="alternate" type="text/html" /><updated>2023-03-08T01:44:45-08:00</updated><id>http://localhost:4000/hcde439/feed.xml</id><title type="html">HCDE 439 - Alex</title><subtitle>Alex&apos;s site for HCDE 439: Physical Computing projects (Winter 2023). Site generated by Jekyll.</subtitle><entry><title type="html">Final project</title><link href="http://localhost:4000/hcde439/jekyll/update/2023/03/07/Final-project.html" rel="alternate" type="text/html" title="Final project" /><published>2023-03-07T16:50:00-08:00</published><updated>2023-03-07T16:50:00-08:00</updated><id>http://localhost:4000/hcde439/jekyll/update/2023/03/07/Final%20project</id><content type="html" xml:base="http://localhost:4000/hcde439/jekyll/update/2023/03/07/Final-project.html"><![CDATA[<h2 id="concept">Concept</h2>
<p>The concept of this project is to make a cheap tiny arcade box that plays a clone of the classic arcade game <em>Pong</em> on a 16x2 character LCD display. This is a “spiritual successor(ancestor)” to the first video game I ever developed which was a clone of <em>Breakout</em> written in Processing. The challenge is to build a game with graphics using very limited hardware.</p>

<h2 id="hardware-implementation">Hardware implementation</h2>
<p>The hardware includes two joysticks installed on the side of a character LCD mounted on the top of a cardboard box. The LCD is connected to the microcontroller via 8 digital pins, 5V power, and ground. The pin for its backlight is connected in series to a 220Ω resistor to limit the current through the backlight as suggested by the guide found on <a href="https://docs.arduino.cc/learn/electronics/lcd-displays">Arduino Docs</a>. A potentiometer installed on the breadboard is used to control the contrast of the display. It is hidden in the box to prevent users from accidentally changing its value.</p>

<p>Since the game experience heavily depends on the smoothness of its graphics &amp; responsiveness of controls, I used all 8 digital pins for the LCD in order to get a small increase in LCD write speed &amp; reduction in latency.</p>

<p>The joysticks are powered by the microcontroller and their y-axis pins are connected to the analog input pins on the Arduino board.</p>

<h3 id="circuit-drawing">Circuit drawing</h3>

<p><img src="/hcde439/assets/final_circuit.png" alt="Circuit drawing" width="80%" /></p>

<h3 id="circuit-photos">Circuit photos</h3>
<p>View of the circuit before it was mounted inside the box</p>

<p><img src="/hcde439/assets/final_circuit_photo0.png" alt="Circuit before mounting" width="70%" /></p>

<p>View of the circuit mounted inside the box</p>

<p><img src="/hcde439/assets/final_circuit_photo1.png" alt="Mounted circuit view (left)" width="49%" />
<img src="/hcde439/assets/final_circuit_photo2.png" alt="Mounted circuit view (right)" width="49%" /></p>

<p>Final product with mounted joysticks &amp; LCD</p>

<p><img src="/hcde439/assets/final_circuit_photo2.png" alt="Final product with mounted joysticks &amp; LCD" width="70%" /></p>

<h2 id="software-implementation">Software implementation</h2>

<h3 id="overview">Overview</h3>
<p>The software implementation is written in Arduino language (C/C++ derivative) and includes the built-in LCD library <code class="language-plaintext highlighter-rouge">LiquidCrystal.h</code>. My firmware is written in C-style code (plus a few C++ features). The main building blocks include game simulation and graphics rendering.</p>

<p>The flowchart below gives an overview of the overall program logic.</p>

<p><img src="/hcde439/assets/final_flowchart.png" alt="Flowchart showing the high-level program logic" width="90%" /></p>

<h3 id="graphics">Graphics</h3>
<p>The main challenge of this project is to draw the game graphics on a character LCD which does not allow individual pixels to be addressed directly. The hardware also lacks suppport for sprites and smooth scrolling. My graphics code implementation simulates those effects using 5 custom characters (2 per paddle, 1 for the ball). It mostly abstracts the LCD screen from the game simulation code, making it relatively easy to implement the actual game logic.</p>

<p>Each custom character is represented as a bitmap stored in an 8-byte array. A 1 in the bitmap represents a pixel on the LCD. For example, the following array will create a custom character that looks like a paddle on the right side of the screen.</p>

<p><img src="/hcde439/assets/final_bitmap_example.png" alt="Bitmap" width="20%" /></p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="n">byte</span> <span class="n">customChar</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
  <span class="n">B00000</span><span class="p">,</span>
  <span class="n">B00001</span><span class="p">,</span>
  <span class="n">B00001</span><span class="p">,</span>
  <span class="n">B00001</span><span class="p">,</span>
  <span class="n">B00001</span><span class="p">,</span>
  <span class="n">B00000</span><span class="p">,</span>
  <span class="n">B00000</span><span class="p">,</span>
  <span class="n">B00000</span>
<span class="p">};</span></code></pre></figure>

<p>Because the <code class="language-plaintext highlighter-rouge">lcd.createChar()</code> function will create a custom character based on the first 8 bytes it reads, I can achieve the effect of moving the paddle up/down by changing where the pointer is pointing within the byte array. Because the padle might span across two vertically stacked characters, two custom characters are used per paddle. Finding the right location within the byte array bitmap is handled by <code class="language-plaintext highlighter-rouge">get_paddle_bitmap()</code>.</p>

<p>The ball character is generated in a similar manner using custom characters. Because the ball can move both vertically and horizontally across the entire screen, its content and the location of that character needs to change over time. Everytime the ball character is updated, the program will clear the charater at its previous location, zero out the entire array, then toggle the correct bit to generate the new bitmap. This task is primarily handled by <code class="language-plaintext highlighter-rouge">ball_sprite()</code>.</p>

<p>As the ball gets closer and close to one of the paddles on screen, it will eventually need to share a custom character with one of the paddles. This is handled by <code class="language-plaintext highlighter-rouge">draw_merge_sprite()</code> that ‘copies’ the paddle bitmap and merge it with the ball sprite before drawing it.</p>

<h3 id="game-simulation">Game simulation</h3>
<p>The game simulation code simlates a <em>Pong</em> game (it is not physically accurate, however). It reads in player input from the joystick, updates the paddles on screen, and moves the ball around the screen. While the graphics code supports letting the ball move in any direction, I decided to limit it to diagnal motion (45 degrees) after testing the actual display’s clarity &amp; responsiveness with different motion patterns. The pong ball will bounce and change direction if it hits the top/bottom wall or a player controlled paddle. The progam delay at the end of <code class="language-plaintext highlighter-rouge">run_session()</code> dictates the game speed.</p>

<p>To improve playability, each paddle is 1 pixel wider in the game logic than it appears on-screen. This is done to compensate the ‘ghosting’ effect of the LCD character display, and it also makes the game feel easier &amp; more forgiving to the players. Because the ball always move in 45 degrees angle, it will also help make the game look more ‘visually correct’.</p>

<p>The game runs at just over 10 fps (frames per second) as determined by the program delay. The main limiting factor is the character LCD as opposed to the software. In my testing, the poor pixel response time makes it very difficult to see the moving ball and paddles if I attempt to run the game at a faster speed. I might be able to resolve this by improving the ball drawing code, but a hardware upgrade to an OLED screen would yield a much more significant improvement.</p>

<h2 id="demo-video">Demo video</h2>
<p><img src="/hcde439/assets/final_demo.mp4" alt="" /></p>

<h2 id="arduino-code">Arduino code</h2>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="c1">// Include external libraries</span>
<span class="cp">#include</span> <span class="cpf">&lt;LiquidCrystal.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;Arduino.h&gt;</span><span class="cp">
</span>
<span class="c1">// Preprocessor macros</span>
<span class="c1">// Defines LCD pins</span>
<span class="cp">#define RS 12
#define ENABLE 11
#define D0 6
#define D1 7
#define D2 8
#define D3 9
#define D4 5
#define D5 4
#define D6 3
#define D7 2
#define PD_L 4
#define PD_R 11
</span>
<span class="c1">// helper enum for handling overlapping ball &amp; paddle</span>
<span class="k">enum</span> <span class="n">DrawOption</span><span class="p">{</span><span class="n">regular</span><span class="p">,</span> <span class="n">upper_left</span><span class="p">,</span> <span class="n">lower_left</span><span class="p">,</span> <span class="n">upper_right</span><span class="p">,</span> <span class="n">lower_right</span><span class="p">};</span>


<span class="c1">// Global variables</span>
<span class="c1">// Initializes LCD object with the predefined pins</span>
<span class="n">LiquidCrystal</span> <span class="nf">lcd</span><span class="p">(</span><span class="n">RS</span><span class="p">,</span> <span class="n">ENABLE</span><span class="p">,</span> <span class="n">D0</span><span class="p">,</span> <span class="n">D1</span><span class="p">,</span> <span class="n">D2</span><span class="p">,</span> <span class="n">D3</span><span class="p">,</span> <span class="n">D4</span><span class="p">,</span> <span class="n">D5</span><span class="p">,</span> <span class="n">D6</span><span class="p">,</span> <span class="n">D7</span><span class="p">);</span>

<span class="c1">// Source bitmap for ball sprite</span>
<span class="n">byte</span> <span class="n">ball</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
  <span class="mi">0</span><span class="n">b00000</span><span class="p">,</span>
  <span class="mi">0</span><span class="n">b00000</span><span class="p">,</span>
  <span class="mi">0</span><span class="n">b00000</span><span class="p">,</span>
  <span class="mi">0</span><span class="n">b00000</span><span class="p">,</span>
  <span class="mi">0</span><span class="n">b00000</span><span class="p">,</span>
  <span class="mi">0</span><span class="n">b00000</span><span class="p">,</span>
  <span class="mi">0</span><span class="n">b00000</span><span class="p">,</span>
  <span class="mi">0</span><span class="n">b00000</span>
<span class="p">};</span>

<span class="c1">// Source bitmap for paddle sprite</span>
<span class="n">byte</span> <span class="n">paddle_src</span><span class="p">[</span><span class="mi">17</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
  <span class="mi">0</span><span class="n">b00000</span><span class="p">,</span>
  <span class="mi">0</span><span class="n">b00000</span><span class="p">,</span>
  <span class="mi">0</span><span class="n">b00000</span><span class="p">,</span>
  <span class="mi">0</span><span class="n">b00000</span><span class="p">,</span>
  <span class="mi">0</span><span class="n">b00000</span><span class="p">,</span>
  <span class="mi">0</span><span class="n">b00000</span><span class="p">,</span>
  <span class="mi">0</span><span class="n">b00000</span><span class="p">,</span>
  <span class="mi">0</span><span class="n">b00000</span><span class="p">,</span>
  <span class="mi">0</span><span class="n">b00001</span><span class="p">,</span>
  <span class="mi">0</span><span class="n">b00001</span><span class="p">,</span>
  <span class="mi">0</span><span class="n">b00001</span><span class="p">,</span>
  <span class="mi">0</span><span class="n">b00001</span><span class="p">,</span>
  <span class="mi">0</span><span class="n">b00000</span><span class="p">,</span>
  <span class="mi">0</span><span class="n">b00000</span><span class="p">,</span>
  <span class="mi">0</span><span class="n">b00000</span><span class="p">,</span>
  <span class="mi">0</span><span class="n">b00000</span><span class="p">,</span>
  <span class="mi">0</span><span class="n">b00000</span>
<span class="p">};</span>

<span class="c1">// Struct for holding the two byte pointers pointing to the location to represent</span>
<span class="c1">// paddles</span>
<span class="k">struct</span> <span class="n">paddle_loc</span> <span class="p">{</span>
  <span class="n">byte</span><span class="o">*</span> <span class="n">upper</span><span class="p">;</span>
  <span class="n">byte</span><span class="o">*</span> <span class="n">lower</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// Struct for holding a pair of coordinates or (col, row) pair</span>
<span class="k">struct</span> <span class="n">coordinate</span> <span class="p">{</span>
  <span class="kt">int8_t</span> <span class="n">x</span><span class="p">;</span>
  <span class="kt">int8_t</span> <span class="n">y</span><span class="p">;</span>
<span class="p">};</span>


<span class="c1">// Declare helper functions</span>
<span class="c1">// Flips the character bitmap for paddle from left to right or vice versa</span>
<span class="c1">// @param src: source bitmap for paddle</span>
<span class="c1">// @param to_right: whether to flip the paddle to the right or left</span>
<span class="kt">void</span> <span class="nf">flip_paddle_bitmap</span><span class="p">(</span><span class="n">byte</span><span class="o">*</span> <span class="n">src</span><span class="p">,</span> <span class="n">bool</span> <span class="n">to_right</span><span class="p">);</span>

<span class="c1">// Generate a struct of two pointers pointing to the starting address within the bitmap</span>
<span class="c1">// that will be drawn as a paddle in game</span>
<span class="c1">// @param src: A byte pointer to the source bitmap for paddles</span>
<span class="c1">// @param posn: The paddle's position</span>
<span class="c1">// @return: A paddle_loc struct with 2 pointers to where the upper &amp; lower bitmap should start</span>
<span class="k">struct</span> <span class="n">paddle_loc</span> <span class="nf">get_paddle_bitmap</span><span class="p">(</span><span class="n">byte</span><span class="o">*</span> <span class="n">src</span><span class="p">,</span> <span class="kt">int8_t</span> <span class="n">posn</span><span class="p">);</span>

<span class="c1">// Handles drawing for overlapping ball &amp; paddle sprite</span>
<span class="c1">// @param b_loc: The character location to draw the merged sprite</span>
<span class="c1">// @param ball: Byte pointer to the btimap for the ball</span>
<span class="c1">// @param paddle: Byte pointer to the bitmap of the paddle</span>
<span class="kt">void</span> <span class="nf">draw_merged_sprite</span><span class="p">(</span><span class="k">struct</span> <span class="n">coordinate</span><span class="o">&amp;</span> <span class="n">b_loc</span><span class="p">,</span> <span class="n">byte</span><span class="o">*</span> <span class="n">ball</span><span class="p">,</span> <span class="n">byte</span><span class="o">*</span> <span class="n">paddle</span><span class="p">);</span>

<span class="c1">// Generate the character bitmap for the ball at `posn`, calculates the character location,</span>
<span class="c1">// and clears the previous character location that contained the ball</span>
<span class="c1">// `ret_val` is a return variable</span>
<span class="c1">// @param posn: Current coordinate of the ball</span>
<span class="c1">// @param prev: Previous coordinate of the ball</span>
<span class="c1">// @param ret_val: Return variable, returns the character location containing the ball</span>
<span class="c1">// @return: A byte pointer to the ball sprite</span>
<span class="n">byte</span><span class="o">*</span> <span class="nf">ball_sprite</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">coordinate</span><span class="o">&amp;</span> <span class="n">posn</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">coordinate</span><span class="o">&amp;</span> <span class="n">prev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">coordinate</span><span class="o">&amp;</span> <span class="n">ret_val</span><span class="p">);</span>

<span class="c1">// Draws a custom character at a given character location on screen</span>
<span class="c1">// @param custom_char: The custom character to use (betwwen 0 and 7)</span>
<span class="c1">// @param bitmap: A byte pointer to the bitmap to apply to this character</span>
<span class="c1">// @param col: The column to place the character</span>
<span class="c1">// @param row: The row to place the character</span>
<span class="kt">void</span> <span class="nf">draw_char</span><span class="p">(</span><span class="k">const</span> <span class="kt">uint8_t</span><span class="o">&amp;</span> <span class="n">custom_char</span><span class="p">,</span> <span class="n">byte</span><span class="o">*</span> <span class="n">bitmap</span><span class="p">,</span> <span class="k">const</span> <span class="kt">uint8_t</span><span class="o">&amp;</span> <span class="n">col</span><span class="p">,</span> <span class="k">const</span> <span class="kt">uint8_t</span><span class="o">&amp;</span> <span class="n">row</span><span class="p">);</span>

<span class="c1">// Reads joystick input from a given analog pin</span>
<span class="c1">// @param:  Analog pin to read</span>
<span class="c1">// @return: an int16_t between -2 and 2</span>
<span class="kt">int16_t</span> <span class="nf">read_input</span><span class="p">(</span><span class="kt">uint8_t</span> <span class="n">pin</span><span class="p">);</span>

<span class="c1">// Renders the game graphics based on the ball location/sprite</span>
<span class="c1">// @param b_loc: A coordinate struct representing the ball's character location</span>
<span class="c1">// @param b: A byte pointer pointing to the bitmap for ball sprite</span>
<span class="c1">// @param paddle_src: Pointer to the source bitmap for paddles</span>
<span class="c1">// @param paddle_l: Represents the left paddle's position</span>
<span class="c1">// @param paddle_r: Represents the right paddle's position</span>
<span class="kt">void</span> <span class="nf">render</span><span class="p">(</span><span class="k">struct</span> <span class="n">coordinate</span><span class="o">&amp;</span> <span class="n">b_loc</span><span class="p">,</span> <span class="n">byte</span><span class="o">*</span> <span class="n">b</span><span class="p">,</span> <span class="n">byte</span><span class="o">*</span> <span class="n">paddle_src</span><span class="p">,</span> <span class="kt">int8_t</span> <span class="n">paddle_l</span><span class="p">,</span> <span class="kt">int8_t</span> <span class="n">paddle_r</span><span class="p">);</span>


<span class="c1">// Main program</span>
<span class="c1">// Setup code, run once</span>
<span class="kt">void</span> <span class="nf">setup</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// set up the LCD's number of columns and rows:</span>
  <span class="n">lcd</span><span class="p">.</span><span class="n">begin</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
  <span class="c1">// Disable cursor</span>
  <span class="n">lcd</span><span class="p">.</span><span class="n">noCursor</span><span class="p">();</span>
<span class="p">}</span>

<span class="c1">// Loop: Repeatly run the game</span>
<span class="kt">void</span> <span class="nf">loop</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">run_session</span><span class="p">();</span>
    <span class="n">delay</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
<span class="p">}</span>


<span class="c1">// Helper function implementations</span>
<span class="kt">int16_t</span> <span class="nf">read_input</span><span class="p">(</span><span class="kt">uint8_t</span> <span class="n">pin</span><span class="p">){</span>
  <span class="c1">// Read from the supplied analog pin then subtract 511</span>
  <span class="kt">int16_t</span> <span class="n">reading</span> <span class="o">=</span> <span class="n">analogRead</span><span class="p">(</span><span class="n">pin</span><span class="p">)</span> <span class="o">-</span> <span class="mi">511</span><span class="p">;</span>
  <span class="c1">// If the joystick is pushed to the extremes, return -2 or 2</span>
  <span class="k">if</span><span class="p">(</span><span class="n">abs</span><span class="p">(</span><span class="n">reading</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">495</span><span class="p">){</span>
    <span class="k">return</span> <span class="n">reading</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">?</span> <span class="o">-</span><span class="mi">2</span> <span class="o">:</span> <span class="mi">2</span><span class="p">;</span>
  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">abs</span><span class="p">(</span><span class="n">reading</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">200</span><span class="p">){</span>  <span class="c1">// or return -1 or 1</span>
    <span class="k">return</span> <span class="n">reading</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">?</span> <span class="o">-</span><span class="mi">1</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>  <span class="c1">// Joystick is in deadzone, return 0</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">run_session</span><span class="p">(){</span>
  <span class="c1">// Struct for holding the ball character location</span>
  <span class="k">struct</span> <span class="n">coordinate</span> <span class="n">ball_char_loc</span><span class="p">;</span>

  <span class="c1">// Coordinate structs holding the ball's current and previous position.</span>
  <span class="c1">// coordiantes are absolute to the top left corner of the screen in logical pixels</span>
  <span class="k">struct</span> <span class="n">coordinate</span> <span class="n">curr_posn</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">coordinate</span> <span class="n">prev_posn</span><span class="p">;</span>

  <span class="c1">// Represents the current velocity of the ball in x and y directions</span>
  <span class="kt">int</span> <span class="n">v_x</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">v_y</span><span class="p">;</span>

  <span class="c1">// Pointer to the ball sprite</span>
  <span class="n">byte</span><span class="o">*</span> <span class="n">b</span><span class="p">;</span>

  <span class="c1">// Represents the left &amp; right paddle's position</span>
  <span class="kt">int8_t</span> <span class="n">paddle_l</span><span class="p">;</span>
  <span class="kt">int8_t</span> <span class="n">paddle_r</span><span class="p">;</span>

  <span class="c1">// Initialize ball position</span>
  <span class="n">curr_posn</span> <span class="o">=</span> <span class="p">{</span><span class="mi">45</span><span class="p">,</span> <span class="p">(</span><span class="kt">int8_t</span><span class="p">)(</span><span class="n">millis</span><span class="p">()</span> <span class="o">%</span> <span class="mi">17</span><span class="p">)};</span>
  <span class="n">prev_posn</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">};</span>

  <span class="c1">// Generate initial velocity</span>
  <span class="n">v_x</span> <span class="o">=</span> <span class="n">millis</span><span class="p">()</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
  <span class="n">v_y</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="c1">// Initial paddle location</span>
  <span class="n">paddle_l</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
  <span class="n">paddle_r</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
  <span class="n">bool</span> <span class="n">sensor_clock</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
  <span class="c1">// Tracks game state</span>
  <span class="n">bool</span> <span class="n">is_alive</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
  <span class="k">while</span><span class="p">(</span><span class="n">is_alive</span><span class="p">){</span>
    <span class="c1">// Optional: read from joystick every/every other program cycle</span>
    <span class="k">if</span><span class="p">(</span><span class="n">sensor_clock</span><span class="p">){</span>
      <span class="n">paddle_r</span> <span class="o">+=</span> <span class="n">read_input</span><span class="p">(</span><span class="n">A0</span><span class="p">);</span>
      <span class="n">paddle_l</span> <span class="o">-=</span> <span class="n">read_input</span><span class="p">(</span><span class="n">A1</span><span class="p">);</span>
      <span class="c1">// sensor_clock = false;  // Comment or uncomment this line to half the paddle speed</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="n">sensor_clock</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">// Constrain paddles to valid range</span>
    <span class="n">paddle_l</span> <span class="o">=</span> <span class="n">constrain</span><span class="p">(</span><span class="n">paddle_l</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">13</span><span class="p">);</span>
    <span class="n">paddle_r</span> <span class="o">=</span> <span class="n">constrain</span><span class="p">(</span><span class="n">paddle_r</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">13</span><span class="p">);</span>

    <span class="c1">// Update current position based on x,y velocities</span>
    <span class="n">curr_posn</span><span class="p">.</span><span class="n">x</span><span class="o">+=</span> <span class="n">v_x</span><span class="p">;</span>
    <span class="n">curr_posn</span><span class="p">.</span><span class="n">y</span><span class="o">+=</span> <span class="n">v_y</span><span class="p">;</span>
    
    <span class="c1">// Bounce off the top/bottom of the screen</span>
    <span class="k">if</span> <span class="err">\</span><span class="p">(</span><span class="n">curr</span><span class="err">\</span><span class="n">_posn</span><span class="p">.</span><span class="n">y</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="err">\</span><span class="o">||</span> <span class="n">curr</span><span class="err">\</span><span class="n">_posn</span><span class="p">.</span><span class="n">y</span> <span class="o">&gt;=</span> <span class="mi">16</span><span class="p">){</span>
      <span class="n">v_y</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="c1">// Checks if the ball will land on the left paddle</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">curr_posn</span><span class="p">.</span><span class="n">x</span> <span class="o">&lt;=</span> <span class="mi">24</span><span class="p">){</span>
      <span class="c1">// Bounce the ball if it will land on the left paddle</span>
      <span class="k">if</span><span class="p">(</span><span class="n">curr_posn</span><span class="p">.</span><span class="n">y</span> <span class="o">&gt;=</span> <span class="n">paddle_l</span><span class="o">-</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">curr_posn</span><span class="p">.</span><span class="n">y</span> <span class="o">&lt;</span> <span class="n">paddle_l</span> <span class="o">+</span> <span class="mi">5</span><span class="p">){</span>
        <span class="n">v_x</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>  <span class="c1">// Otherwise end the game</span>
        <span class="n">is_alive</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
      <span class="p">}</span>      
    <span class="p">}</span>

    <span class="c1">// Checks if the ball will land on the right paddle</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">curr_posn</span><span class="p">.</span><span class="n">x</span> <span class="o">&gt;=</span> <span class="mi">70</span><span class="p">){</span>
      <span class="c1">// Bounce the ball if it will land on the right paddle</span>
      <span class="k">if</span><span class="p">(</span><span class="n">curr_posn</span><span class="p">.</span><span class="n">y</span> <span class="o">&gt;=</span> <span class="n">paddle_r</span><span class="o">-</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">curr_posn</span><span class="p">.</span><span class="n">y</span> <span class="o">&lt;</span> <span class="n">paddle_r</span> <span class="o">+</span> <span class="mi">5</span><span class="p">){</span>
        <span class="n">v_x</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>  <span class="c1">// Otherwise end the game</span>
        <span class="n">is_alive</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
      <span class="p">}</span>      
    <span class="p">}</span>

    <span class="c1">// Get the bitmap &amp; character location for the ball</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">ball_sprite</span><span class="p">(</span><span class="n">curr_posn</span><span class="p">,</span> <span class="n">prev_posn</span><span class="p">,</span> <span class="n">ball_char_loc</span><span class="p">);</span>
    
    <span class="c1">// Save this position (x,y)</span>
    <span class="n">prev_posn</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">curr_posn</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
    <span class="n">prev_posn</span><span class="p">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">curr_posn</span><span class="p">.</span><span class="n">y</span><span class="p">;</span>

    <span class="c1">// Draw graphics based on ball &amp; paddle locations</span>
    <span class="n">render</span><span class="p">(</span><span class="n">ball_char_loc</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">paddle_src</span><span class="p">,</span> <span class="n">paddle_l</span><span class="p">,</span> <span class="n">paddle_r</span><span class="p">);</span>
    
    <span class="c1">// Program delay, controls game speed &amp; latency</span>
    <span class="n">delay</span><span class="p">(</span><span class="mi">70</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="c1">// Add a longer delay when a player wins</span>
  <span class="n">delay</span><span class="p">(</span><span class="mi">2000</span><span class="p">);</span>
<span class="p">}</span>


<span class="c1">// Flips the character bitmap for paddle from left to right or vice versa</span>
<span class="kt">void</span> <span class="nf">flip_paddle_bitmap</span><span class="p">(</span><span class="n">byte</span><span class="o">*</span> <span class="n">src</span><span class="p">,</span> <span class="n">bool</span> <span class="n">to_right</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">uint8_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>
  <span class="c1">// Right shift by 4 (to get right paddle)</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">to_right</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">12</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">src</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">src</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="c1">// Left shift by 4 (to get left paddle)</span>
  <span class="k">for</span> <span class="p">(;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">12</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">src</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">src</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>


<span class="k">struct</span> <span class="n">paddle_loc</span> <span class="nf">get_paddle_bitmap</span><span class="p">(</span><span class="n">byte</span><span class="o">*</span> <span class="n">src</span><span class="p">,</span> <span class="kt">int8_t</span> <span class="n">posn</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">struct</span> <span class="n">paddle_loc</span> <span class="n">ret_val</span><span class="p">;</span>
  <span class="c1">// Calculate upper character for the paddle</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">posn</span> <span class="o">&lt;=</span> <span class="mi">8</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">ret_val</span><span class="p">.</span><span class="n">upper</span> <span class="o">=</span> <span class="n">src</span> <span class="o">+</span> <span class="p">(</span><span class="mi">8</span> <span class="o">-</span> <span class="n">posn</span><span class="p">);</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="n">ret_val</span><span class="p">.</span><span class="n">upper</span> <span class="o">=</span> <span class="n">src</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="c1">// Calculate lower character for the paddle</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">posn</span> <span class="o">&lt;=</span> <span class="mi">5</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">ret_val</span><span class="p">.</span><span class="n">lower</span> <span class="o">=</span> <span class="n">src</span><span class="p">;</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="n">ret_val</span><span class="p">.</span><span class="n">lower</span> <span class="o">=</span> <span class="n">src</span> <span class="o">+</span> <span class="p">(</span><span class="mi">17</span> <span class="o">-</span> <span class="n">posn</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
<span class="p">}</span>


<span class="n">byte</span><span class="o">*</span> <span class="nf">ball_sprite</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">coordinate</span><span class="o">&amp;</span> <span class="n">posn</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">coordinate</span><span class="o">&amp;</span> <span class="n">prev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">coordinate</span><span class="o">&amp;</span> <span class="n">ret_val</span><span class="p">){</span>
  <span class="c1">// Calculate where the pixel should be within the character</span>
  <span class="kt">int8_t</span> <span class="n">relative_x</span> <span class="o">=</span> <span class="n">posn</span><span class="p">.</span><span class="n">x</span> <span class="o">%</span> <span class="mi">6</span><span class="p">;</span>
  <span class="kt">int8_t</span> <span class="n">relative_y</span> <span class="o">=</span> <span class="n">posn</span><span class="p">.</span><span class="n">y</span> <span class="o">%</span> <span class="mi">9</span><span class="p">;</span>
  
  <span class="c1">// Calculate the row &amp; column to place the sprite</span>
  <span class="n">ret_val</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">posn</span><span class="p">.</span><span class="n">x</span> <span class="o">/</span> <span class="mi">6</span><span class="p">;</span>
  <span class="n">ret_val</span><span class="p">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">posn</span><span class="p">.</span><span class="n">y</span> <span class="o">/</span> <span class="mi">9</span><span class="p">;</span>
  <span class="o">*</span><span class="p">((</span><span class="kt">uint64_t</span><span class="o">*</span><span class="p">)</span><span class="n">ball</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>   <span class="c1">// Reset ball sprite to empty</span>

  <span class="c1">// Ball is on the boundary between characters</span>
  <span class="c1">// Clear previous character and return</span>
  <span class="k">if</span> <span class="err">\</span><span class="p">(</span><span class="n">relative</span><span class="err">\</span><span class="n">_x</span> <span class="o">==</span> <span class="mi">5</span> <span class="err">\</span><span class="o">||</span> <span class="n">relative</span><span class="err">\</span><span class="n">_y</span> <span class="o">==</span> <span class="mi">8</span><span class="p">){</span>
    <span class="c1">// Move cursor and directly write an empty charcter</span>
    <span class="n">lcd</span><span class="p">.</span><span class="n">setCursor</span><span class="p">(</span><span class="n">prev</span><span class="p">.</span><span class="n">x</span> <span class="o">/</span> <span class="mi">6</span><span class="p">,</span> <span class="n">prev</span><span class="p">.</span><span class="n">y</span> <span class="o">/</span> <span class="mi">9</span><span class="p">);</span>
    <span class="n">lcd</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="n">byte</span><span class="p">(</span><span class="mi">32</span><span class="p">));</span>
    <span class="k">return</span> <span class="n">ball</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// Clear the previous character if the ball is now on a different character</span>
  <span class="k">if</span> <span class="err">\</span><span class="p">(</span><span class="n">posn</span><span class="p">.</span><span class="n">x</span> <span class="o">!=</span> <span class="n">prev</span><span class="p">.</span><span class="n">x</span><span class="o">/</span><span class="mi">6</span> <span class="err">\</span><span class="o">||</span> <span class="n">posn</span><span class="p">.</span><span class="n">y</span> <span class="o">!=</span> <span class="n">prev</span><span class="p">.</span><span class="n">y</span><span class="o">/</span><span class="mi">9</span><span class="p">){</span>
    <span class="c1">// Move cursor and directly write an empty charcter</span>
    <span class="n">lcd</span><span class="p">.</span><span class="n">setCursor</span><span class="p">(</span><span class="n">prev</span><span class="p">.</span><span class="n">x</span> <span class="o">/</span> <span class="mi">6</span><span class="p">,</span> <span class="n">prev</span><span class="p">.</span><span class="n">y</span> <span class="o">/</span> <span class="mi">9</span><span class="p">);</span>
    <span class="n">lcd</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="n">byte</span><span class="p">(</span><span class="mi">32</span><span class="p">));</span>
  <span class="p">}</span>

  <span class="c1">// Create the new ball sprite</span>
  <span class="n">ball</span><span class="p">[</span><span class="n">relative_y</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="mi">4</span><span class="o">-</span><span class="n">relative_x</span><span class="p">);</span> <span class="c1">// Shift the ball pixel</span>
  <span class="k">return</span> <span class="n">ball</span><span class="p">;</span>
<span class="p">}</span>


<span class="kt">void</span> <span class="nf">draw_merged_sprite</span><span class="p">(</span><span class="k">struct</span> <span class="n">coordinate</span><span class="o">&amp;</span> <span class="n">b_loc</span><span class="p">,</span> <span class="n">byte</span><span class="o">*</span> <span class="n">ball</span><span class="p">,</span> <span class="n">byte</span><span class="o">*</span> <span class="n">paddle</span><span class="p">){</span>
  <span class="err">\</span><span class="o">*</span><span class="err">\</span><span class="p">(</span><span class="n">uint64</span><span class="err">\</span><span class="n">_t</span><span class="err">\</span><span class="o">*</span><span class="p">)</span><span class="n">ball</span> <span class="o">|=</span> <span class="err">\</span><span class="o">*</span><span class="err">\</span><span class="p">(</span><span class="n">uint64</span><span class="err">\</span><span class="n">_t</span><span class="err">\</span><span class="o">*</span><span class="p">)</span><span class="n">paddle</span><span class="p">;</span>
  <span class="n">draw_char</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="n">ball</span><span class="p">,</span> <span class="n">b_loc</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">b_loc</span><span class="p">.</span><span class="n">y</span><span class="p">);</span>
<span class="p">}</span>


<span class="kt">void</span> <span class="nf">draw_char</span><span class="p">(</span><span class="k">const</span> <span class="kt">uint8_t</span><span class="o">&amp;</span> <span class="n">custom_char</span><span class="p">,</span> <span class="n">byte</span><span class="o">*</span> <span class="n">bitmap</span><span class="p">,</span> <span class="k">const</span> <span class="kt">uint8_t</span><span class="o">&amp;</span> <span class="n">col</span><span class="p">,</span> <span class="k">const</span> <span class="kt">uint8_t</span><span class="o">&amp;</span> <span class="n">row</span><span class="p">){</span>
  <span class="c1">// Create custome character from bitmap</span>
  <span class="n">lcd</span><span class="p">.</span><span class="n">createChar</span><span class="p">(</span><span class="n">custom_char</span><span class="p">,</span> <span class="n">bitmap</span><span class="p">);</span>
  <span class="c1">// Move cursor</span>
  <span class="n">lcd</span><span class="p">.</span><span class="n">setCursor</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="n">row</span><span class="p">);</span>
  <span class="c1">// Write custome character</span>
  <span class="n">lcd</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="n">byte</span><span class="p">(</span><span class="n">custom_char</span><span class="p">));</span>
<span class="p">}</span>


<span class="kt">void</span> <span class="nf">render</span><span class="p">(</span><span class="k">struct</span> <span class="n">coordinate</span><span class="o">&amp;</span> <span class="n">b_loc</span><span class="p">,</span> <span class="n">byte</span><span class="o">*</span> <span class="n">b</span><span class="p">,</span> <span class="n">byte</span><span class="o">*</span> <span class="n">paddle</span><span class="p">,</span> <span class="kt">int8_t</span> <span class="n">paddle_l</span><span class="p">,</span> <span class="kt">int8_t</span> <span class="n">paddle_r</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// Determine the necessary draw options</span>
  <span class="n">DrawOption</span> <span class="n">opt</span> <span class="o">=</span> <span class="n">regular</span><span class="p">;</span> <span class="c1">// Assume ball does not overlap with any paddles</span>
  
  <span class="c1">// Optionally merge with left/right paddle</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">b_loc</span><span class="p">.</span><span class="n">x</span> <span class="o">==</span> <span class="n">PD_L</span><span class="p">){</span> <span class="c1">// left</span>
    <span class="n">opt</span> <span class="o">=</span> <span class="p">(</span><span class="n">b_loc</span><span class="p">.</span><span class="n">y</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">?</span> <span class="n">upper_left</span> <span class="o">:</span> <span class="n">lower_left</span><span class="p">;</span>   <span class="c1">// overlap with upper or lower half?</span>
  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">b_loc</span><span class="p">.</span><span class="n">x</span> <span class="o">==</span> <span class="n">PD_R</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// right</span>
    <span class="n">opt</span> <span class="o">=</span> <span class="p">(</span><span class="n">b_loc</span><span class="p">.</span><span class="n">y</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">?</span> <span class="n">upper_right</span> <span class="o">:</span> <span class="n">lower_right</span><span class="p">;</span> <span class="c1">// overlap with upper or lower half?</span>
  <span class="p">}</span>
  
  <span class="c1">// Get bitmap for right paddles</span>
  <span class="k">struct</span> <span class="n">paddle_loc</span> <span class="n">pd</span> <span class="o">=</span> <span class="n">get_paddle_bitmap</span><span class="p">(</span><span class="n">paddle</span><span class="p">,</span> <span class="n">paddle_r</span><span class="p">);</span>

  <span class="c1">// Draw the upper half right paddle</span>
  <span class="k">if</span><span class="p">(</span><span class="n">opt</span> <span class="o">==</span> <span class="n">upper_right</span><span class="p">){</span>
    <span class="c1">// Merge upper half of right paddle with the ball</span>
    <span class="n">draw_merged_sprite</span><span class="p">(</span><span class="n">b_loc</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">pd</span><span class="p">.</span><span class="n">upper</span><span class="p">);</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="c1">// draw directly</span>
    <span class="n">draw_char</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">pd</span><span class="p">.</span><span class="n">upper</span><span class="p">,</span> <span class="n">PD_R</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="c1">// Draws the lower half of right paddle</span>
  <span class="k">if</span><span class="p">(</span><span class="n">opt</span> <span class="o">==</span> <span class="n">lower_right</span><span class="p">){</span>
    <span class="c1">// Merge lower half of right paddle with the ball</span>
    <span class="n">draw_merged_sprite</span><span class="p">(</span><span class="n">b_loc</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">pd</span><span class="p">.</span><span class="n">lower</span><span class="p">);</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="c1">// draw directly</span>
    <span class="n">draw_char</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">pd</span><span class="p">.</span><span class="n">lower</span><span class="p">,</span> <span class="n">PD_R</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="c1">//  Get right paddle bitmap &amp; flip the 1 bits to left side</span>
  <span class="n">pd</span> <span class="o">=</span> <span class="n">get_paddle_bitmap</span><span class="p">(</span><span class="n">paddle</span><span class="p">,</span> <span class="n">paddle_l</span><span class="p">);</span>
  <span class="n">flip_paddle_bitmap</span><span class="p">(</span><span class="n">paddle</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>

  <span class="c1">// Draws the upper half of left paddle</span>
  <span class="k">if</span><span class="p">(</span><span class="n">opt</span> <span class="o">==</span> <span class="n">upper_left</span><span class="p">){</span>
    <span class="c1">// Merge upper half of left paddle with the ball</span>
    <span class="n">draw_merged_sprite</span><span class="p">(</span><span class="n">b_loc</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">pd</span><span class="p">.</span><span class="n">upper</span><span class="p">);</span>
  <span class="p">}</span> <span class="k">else</span><span class="p">{</span>
    <span class="c1">// draw directly</span>
    <span class="n">draw_char</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">pd</span><span class="p">.</span><span class="n">upper</span><span class="p">,</span> <span class="n">PD_L</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="c1">// Draws the lower half of left paddle</span>
  <span class="k">if</span><span class="p">(</span><span class="n">opt</span> <span class="o">==</span> <span class="n">lower_left</span><span class="p">){</span>
    <span class="c1">// Merge lower half of right paddle with the ball</span>
    <span class="n">draw_merged_sprite</span><span class="p">(</span><span class="n">b_loc</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">pd</span><span class="p">.</span><span class="n">lower</span><span class="p">);</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="c1">// draw directly</span>
    <span class="n">draw_char</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">pd</span><span class="p">.</span><span class="n">lower</span><span class="p">,</span> <span class="n">PD_L</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="c1">// Flips the paddle bitmap back to its original position</span>
  <span class="n">flip_paddle_bitmap</span><span class="p">(</span><span class="n">paddle</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>

  <span class="c1">// Draws the ball separately if it doesn't overlap with anything</span>
  <span class="k">if</span><span class="p">(</span><span class="n">opt</span> <span class="o">==</span> <span class="n">regular</span><span class="p">){</span>
    <span class="n">draw_char</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">b_loc</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">b_loc</span><span class="p">.</span><span class="n">y</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure>]]></content><author><name></name></author><category term="jekyll" /><category term="update" /><summary type="html"><![CDATA[Concept The concept of this project is to make a cheap tiny arcade box that plays a clone of the classic arcade game Pong on a 16x2 character LCD display. This is a “spiritual successor(ancestor)” to the first video game I ever developed which was a clone of Breakout written in Processing. The challenge is to build a game with graphics using very limited hardware.]]></summary></entry><entry><title type="html">Final project proposal</title><link href="http://localhost:4000/hcde439/jekyll/update/2023/02/27/Final-project-proposal.html" rel="alternate" type="text/html" title="Final project proposal" /><published>2023-02-27T10:20:00-08:00</published><updated>2023-02-27T10:20:00-08:00</updated><id>http://localhost:4000/hcde439/jekyll/update/2023/02/27/Final%20project%20proposal</id><content type="html" xml:base="http://localhost:4000/hcde439/jekyll/update/2023/02/27/Final-project-proposal.html"><![CDATA[<h2 id="demo">Demo</h2>
<p>I would like to attempt to make a cheap tiny arcade box that plays Pong (clone) on the 16x2 character LCD display. This would be a “spiritual successor(ancestor)” to the first (maybe second) game I ever made which was a clone of Breakout written in processing. The difference is I will be using much more limited hardware this time.</p>

<h2 id="timeline">Timeline</h2>
<ul>
  <li>2/28	Feasibility &amp; LCD stress test</li>
  <li>3/1	Connect joysticks to the system</li>
  <li>3/3	Implement graphics code</li>
  <li>3/5	Implement game logic</li>
  <li>3/6	Package hardware into a box</li>
  <li>3/8	Documentation</li>
  <li>3/9	Presentation</li>
</ul>

<h2 id="anticipated-bill-of-materials">Anticipated Bill of Materials</h2>
<ul>
  <li>16x2 character LCD</li>
  <li>Arduino</li>
  <li>Resistor</li>
  <li>Cardboard box</li>
  <li>2 Joysticks</li>
</ul>

<h2 id="backup-plans">Backup plans</h2>
<p>If feasibility testing &amp; LCD stress test fails or other significant issues are encountered before 3/4, I might pivot towards a security system project that combines motion sensor/ultrasonic sensor with LEDs.</p>

<h2 id="anticipated-issues">Anticipated issues</h2>
<p>Based on preliminary research/testing, I have identified the following issues that will need to be resolved:</p>
<ul>
  <li>Sprites &amp; graphics will have to be emulated in software with 8 custom characters, potentially causing significant slowdowns.</li>
  <li>There’s no hardware scrolling for graphics so that will also need to be done in software.</li>
</ul>]]></content><author><name></name></author><category term="jekyll" /><category term="update" /><summary type="html"><![CDATA[Demo I would like to attempt to make a cheap tiny arcade box that plays Pong (clone) on the 16x2 character LCD display. This would be a “spiritual successor(ancestor)” to the first (maybe second) game I ever made which was a clone of Breakout written in processing. The difference is I will be using much more limited hardware this time.]]></summary></entry><entry><title type="html">Assignment 6: Talking to the web! (via Serial)</title><link href="http://localhost:4000/hcde439/jekyll/update/2023/02/27/Assignment-6-Web-and-serial.html" rel="alternate" type="text/html" title="Assignment 6: Talking to the web! (via Serial)" /><published>2023-02-27T01:23:00-08:00</published><updated>2023-02-27T01:23:00-08:00</updated><id>http://localhost:4000/hcde439/jekyll/update/2023/02/27/Assignment%206%20Web%20and%20serial</id><content type="html" xml:base="http://localhost:4000/hcde439/jekyll/update/2023/02/27/Assignment-6-Web-and-serial.html"><![CDATA[<h2 id="demo">Demo</h2>
<p><strong>Sending joystick data to webpage &amp; receiving keyboard input from browser</strong><br />
Demo video showing the joystick controlling a ball on screen that changes color depending on its distance from the boarder of the frame. The LCD connected to Arduino prints out keystrokes entered on the webpage.</p>

<p><img src="/hcde439/assets/hw6_demo.gif" alt="Demo video" width="75%" /></p>

<h2 id="circuit-drawing">Circuit drawing</h2>
<p>The LCD is connected to the microcontroller via digital pins, 5V power, and ground. The pin for its backlight is connected in series to a 220Ω resistor to limit the current through the backlight as suggested by the guide found on <a href="https://docs.arduino.cc/learn/electronics/lcd-displays">Arduino Docs</a>.</p>

<p>The joystick is powered by the same 5V pin on Arduino and its two analog output pins are connected to port A0 and A1 for x &amp; y axis respectively.</p>

<p><img src="/hcde439/assets/hw6_circuit.png" alt="Circuit drawing" width="80%" /></p>

<p><img src="/hcde439/assets/hw6_circuit_photo.png" alt="Circuit photo" width="80%" /></p>

<h2 id="arduino-code">Arduino code</h2>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="c1">// Import LCD library</span>
<span class="cp">#include</span> <span class="cpf">&lt;LiquidCrystal.h&gt;</span><span class="cp">
</span>
<span class="c1">// Preprocessor macros</span>
<span class="c1">// Defines joystick pins for X &amp; Y axis</span>
<span class="cp">#define X_PIN A1
#define Y_PIN A0  // Both maps to analog inputs
</span>
<span class="c1">// Define LCD pins as constants</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">rs</span> <span class="o">=</span> <span class="mi">12</span><span class="p">,</span> <span class="n">en</span> <span class="o">=</span> <span class="mi">11</span><span class="p">,</span> <span class="n">d4</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span> <span class="n">d5</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span> <span class="n">d6</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span> <span class="n">d7</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="n">d3</span> <span class="o">=</span> <span class="mi">9</span><span class="p">,</span> <span class="n">d0</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span> <span class="n">d1</span><span class="o">=</span><span class="mi">7</span><span class="p">,</span> <span class="n">d2</span><span class="o">=</span><span class="mi">8</span><span class="p">;</span>
<span class="c1">// Creates a LCD object</span>
<span class="n">LiquidCrystal</span> <span class="nf">lcd</span><span class="p">(</span><span class="n">rs</span><span class="p">,</span> <span class="n">en</span><span class="p">,</span> <span class="n">d0</span><span class="p">,</span> <span class="n">d1</span><span class="p">,</span> <span class="n">d2</span><span class="p">,</span> <span class="n">d3</span><span class="p">,</span> <span class="n">d4</span><span class="p">,</span> <span class="n">d5</span><span class="p">,</span> <span class="n">d6</span><span class="p">,</span> <span class="n">d7</span><span class="p">);</span>
<span class="n">bool</span> <span class="n">is_upper</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

<span class="c1">// Setup code: Run once</span>
<span class="kt">void</span> <span class="nf">setup</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// Set up serial communication</span>
  <span class="n">Serial</span><span class="p">.</span><span class="n">begin</span><span class="p">(</span><span class="mi">9600</span><span class="p">);</span>
  <span class="c1">// Initialize LCD object with the LCD size</span>
  <span class="n">lcd</span><span class="p">.</span><span class="n">begin</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span><span class="mi">2</span><span class="p">);</span>
  <span class="c1">// Move cursor to bottom right corner</span>
  <span class="n">lcd</span><span class="p">.</span><span class="n">setCursor</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
  <span class="c1">// Enable autoscroll</span>
  <span class="n">lcd</span><span class="p">.</span><span class="n">autoscroll</span><span class="p">();</span>
<span class="p">}</span>

<span class="c1">// Interactive program: Infinite loop</span>
<span class="kt">void</span> <span class="nf">loop</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// Read form both X and Y axis of the joystick</span>
  <span class="kt">int</span> <span class="n">s1</span> <span class="o">=</span> <span class="n">analogRead</span><span class="p">(</span><span class="n">X_PIN</span><span class="p">);</span> <span class="c1">// X-axis</span>
  <span class="kt">int</span> <span class="n">s2</span> <span class="o">=</span> <span class="n">analogRead</span><span class="p">(</span><span class="n">Y_PIN</span><span class="p">);</span> <span class="c1">// Y-axis</span>
  <span class="c1">// Manually generate data in JSON format</span>
  <span class="n">Serial</span><span class="p">.</span><span class="n">print</span><span class="p">(</span><span class="s">"["</span><span class="p">);</span>  <span class="c1">// Opening bracket for a JSON list</span>
  <span class="n">Serial</span><span class="p">.</span><span class="n">print</span><span class="p">(</span><span class="n">s1</span><span class="p">);</span>   <span class="c1">// X-axis value</span>
  <span class="n">Serial</span><span class="p">.</span><span class="n">print</span><span class="p">(</span><span class="s">","</span><span class="p">);</span>  <span class="c1">// Seperator</span>
  <span class="n">Serial</span><span class="p">.</span><span class="n">print</span><span class="p">(</span><span class="n">s2</span><span class="p">);</span>   <span class="c1">// Y-axis value</span>
  <span class="n">Serial</span><span class="p">.</span><span class="n">println</span><span class="p">(</span><span class="s">"]"</span><span class="p">);</span>  <span class="c1">// Closing bracket for a JSON list</span>

  <span class="c1">// Print text to LCD if valid data is received on Serial</span>
  <span class="k">if</span><span class="p">(</span><span class="n">Serial</span><span class="p">.</span><span class="n">available</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">){</span>
    <span class="kt">int</span> <span class="n">inByte</span> <span class="o">=</span> <span class="n">Serial</span><span class="p">.</span><span class="n">read</span><span class="p">();</span>     <span class="c1">// Read serial data if it's available</span>
    <span class="n">lcd</span><span class="p">.</span><span class="n">print</span><span class="p">(</span><span class="kt">char</span><span class="p">(</span><span class="n">inByte</span><span class="p">));</span>  <span class="c1">// Print the data to LCD (cast to char)</span>
  <span class="p">}</span>
  <span class="c1">// Slight program delay</span>
  <span class="n">delay</span><span class="p">(</span><span class="mi">50</span><span class="p">);</span>
<span class="p">}</span></code></pre></figure>

<h2 id="p5js-code">p5.js code</h2>

<figure class="highlight"><pre><code class="language-js" data-lang="js"><span class="kd">var</span> <span class="nx">serial</span><span class="p">;</span> <span class="c1">// variable to hold an instance of the serialport library</span>
<span class="kd">var</span> <span class="nx">portName</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">COM3</span><span class="dl">'</span><span class="p">;</span> <span class="c1">//rename to the name of your port</span>
<span class="kd">var</span> <span class="nx">dataarray</span> <span class="o">=</span> <span class="p">[];</span> <span class="c1">//some data coming in over serial!</span>
<span class="kd">var</span> <span class="nx">xPos</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>


<span class="kd">function</span> <span class="nx">setup</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">serial</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">p5</span><span class="p">.</span><span class="nx">SerialPort</span><span class="p">();</span>       <span class="c1">// make a new instance of the serialport library</span>
  <span class="nx">serial</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="dl">'</span><span class="s1">list</span><span class="dl">'</span><span class="p">,</span> <span class="nx">printList</span><span class="p">);</span>       <span class="c1">// set a callback function for the serialport list event</span>
  <span class="nx">serial</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="dl">'</span><span class="s1">connected</span><span class="dl">'</span><span class="p">,</span> <span class="nx">serverConnected</span><span class="p">);</span> <span class="c1">// callback for connecting to the server</span>
  <span class="nx">serial</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="dl">'</span><span class="s1">open</span><span class="dl">'</span><span class="p">,</span> <span class="nx">portOpen</span><span class="p">);</span>        <span class="c1">// callback for the port opening</span>
  <span class="nx">serial</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="dl">'</span><span class="s1">data</span><span class="dl">'</span><span class="p">,</span> <span class="nx">serialEvent</span><span class="p">);</span>     <span class="c1">// callback for when new data arrives</span>
  <span class="nx">serial</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="dl">'</span><span class="s1">error</span><span class="dl">'</span><span class="p">,</span> <span class="nx">serialError</span><span class="p">);</span>    <span class="c1">// callback for errors</span>
  <span class="nx">serial</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="dl">'</span><span class="s1">close</span><span class="dl">'</span><span class="p">,</span> <span class="nx">portClose</span><span class="p">);</span>      <span class="c1">// callback for the port closing</span>
 
  <span class="nx">serial</span><span class="p">.</span><span class="nx">list</span><span class="p">();</span>                      <span class="c1">// list the serial ports</span>
  <span class="nx">serial</span><span class="p">.</span><span class="nx">open</span><span class="p">(</span><span class="nx">portName</span><span class="p">);</span>              <span class="c1">// open a serial port</span>
  <span class="nx">createCanvas</span><span class="p">(</span><span class="mi">1200</span><span class="p">,</span> <span class="mi">800</span><span class="p">);</span>            <span class="c1">// Create a 1200 x 800 canvas</span>
  <span class="nx">background</span><span class="p">(</span><span class="mi">200</span><span class="p">,</span> <span class="mi">200</span><span class="p">,</span> <span class="mi">200</span><span class="p">);</span>          <span class="c1">// Background</span>
<span class="p">}</span>
 
<span class="c1">// get the list of ports:</span>
<span class="kd">function</span> <span class="nx">printList</span><span class="p">(</span><span class="nx">portList</span><span class="p">)</span> <span class="p">{</span>
 <span class="c1">// portList is an array of serial port names</span>
 <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">portList</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
 <span class="c1">// Display the list the console:</span>
   <span class="nx">print</span><span class="p">(</span><span class="nx">i</span> <span class="o">+</span> <span class="dl">"</span><span class="s2"> </span><span class="dl">"</span> <span class="o">+</span> <span class="nx">portList</span><span class="p">[</span><span class="nx">i</span><span class="p">]);</span>
 <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// Log successful server connection to terminal</span>
<span class="kd">function</span> <span class="nx">serverConnected</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">print</span><span class="p">(</span><span class="dl">'</span><span class="s1">connected to server.</span><span class="dl">'</span><span class="p">);</span>
<span class="p">}</span>
 <span class="c1">// Log port opening to terminal</span>
<span class="kd">function</span> <span class="nx">portOpen</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">print</span><span class="p">(</span><span class="dl">'</span><span class="s1">the serial port opened.</span><span class="dl">'</span><span class="p">)</span>
<span class="p">}</span>
 <span class="c1">// Log serial connection error</span>
<span class="kd">function</span> <span class="nx">serialError</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">print</span><span class="p">(</span><span class="dl">'</span><span class="s1">Something went wrong with the serial port. </span><span class="dl">'</span> <span class="o">+</span> <span class="nx">err</span><span class="p">);</span>
<span class="p">}</span>
 <span class="c1">// Log serial port closure</span>
<span class="kd">function</span> <span class="nx">portClose</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">print</span><span class="p">(</span><span class="dl">'</span><span class="s1">The serial port closed.</span><span class="dl">'</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// Event listener: liustens for event over serial connection</span>
<span class="kd">function</span> <span class="nx">serialEvent</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// Check if there's data to read from serial</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">serial</span><span class="p">.</span><span class="nx">available</span><span class="p">())</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">datastring</span> <span class="o">=</span> <span class="nx">serial</span><span class="p">.</span><span class="nx">readLine</span><span class="p">();</span> <span class="c1">// readin some serial</span>
    <span class="kd">var</span> <span class="nx">newarray</span><span class="p">;</span> 
    <span class="k">try</span> <span class="p">{</span>
      <span class="nx">newarray</span> <span class="o">=</span> <span class="nx">JSON</span><span class="p">.</span><span class="nx">parse</span><span class="p">(</span><span class="nx">datastring</span><span class="p">);</span> <span class="c1">// attempt to parse as a JSON stream</span>
      <span class="k">if</span> <span class="p">(</span><span class="k">typeof</span> <span class="nx">newarray</span> <span class="o">==</span> <span class="dl">'</span><span class="s1">object</span><span class="dl">'</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">dataarray</span> <span class="o">=</span> <span class="nx">newarray</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="c1">// Log to console</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">got back </span><span class="dl">"</span> <span class="o">+</span> <span class="nx">datastring</span><span class="p">);</span>
      <span class="p">}</span> <span class="k">catch</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">// got something that's not a json</span>
    <span class="p">}</span>
  <span class="p">}</span> 
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">graphData</span><span class="p">(</span><span class="nx">newData</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// map the range of the input to the window height:</span>
  <span class="kd">var</span> <span class="nx">yPos</span> <span class="o">=</span> <span class="nx">map</span><span class="p">(</span><span class="nx">newData</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1023</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">height</span><span class="p">);</span>
  <span class="c1">// draw the line</span>
  <span class="nx">line</span><span class="p">(</span><span class="nx">xPos</span><span class="p">,</span> <span class="nx">height</span><span class="p">,</span> <span class="nx">xPos</span><span class="p">,</span> <span class="nx">height</span> <span class="o">-</span> <span class="nx">yPos</span><span class="p">);</span>
  <span class="c1">// at the edge of the screen, go back to the beginning:</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">xPos</span> <span class="o">&gt;=</span> <span class="nx">width</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">xPos</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="c1">// clear the screen by resetting the background:</span>
    <span class="nx">background</span><span class="p">(</span><span class="mh">0x08</span><span class="p">,</span> <span class="mh">0x16</span><span class="p">,</span> <span class="mh">0x40</span><span class="p">);</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="c1">// pass</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">drawSphere</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// clear the screen by resetting the background:</span>
  <span class="nx">background</span><span class="p">(</span><span class="mi">200</span><span class="p">,</span> <span class="mi">200</span><span class="p">,</span> <span class="mi">200</span><span class="p">);</span>
  <span class="kd">let</span> <span class="nx">diameter</span> <span class="o">=</span> <span class="mi">40</span><span class="p">;</span>
  <span class="c1">// Maps Arduion analog read value to the dimensions of the frame</span>
  <span class="kd">let</span> <span class="nx">xPos</span> <span class="o">=</span> <span class="nx">map</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1023</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">width</span><span class="p">);</span>
  <span class="kd">let</span> <span class="nx">yPos</span> <span class="o">=</span> <span class="nx">map</span><span class="p">(</span><span class="nx">y</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1023</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">height</span><span class="p">);</span>  <span class="c1">// Arduion 0-1023 to width/height</span>
  <span class="c1">// Change circle color depending on it's location within the frame</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">abs</span><span class="p">(</span><span class="nx">xPos</span> <span class="o">-</span> <span class="nx">width</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span><span class="o">/</span><span class="nx">width</span> <span class="o">&gt;</span> <span class="mf">0.4</span> <span class="err">\</span><span class="o">|</span><span class="err">\</span><span class="o">|</span> <span class="nx">abs</span><span class="p">(</span><span class="nx">yPos</span> <span class="o">-</span> <span class="nx">height</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span><span class="o">/</span><span class="nx">height</span> <span class="o">&gt;</span> <span class="mf">0.4</span> <span class="p">)</span> <span class="p">{</span>
    <span class="c1">// Draws a red curcle if it's less than 10% of the width/height of the frame</span>
    <span class="nx">fill</span><span class="p">(</span><span class="nx">color</span><span class="p">(</span><span class="mi">256</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">));</span>   <span class="c1">// Set shape filling color to red</span>
  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="nx">abs</span><span class="p">(</span><span class="nx">xPos</span> <span class="o">-</span> <span class="nx">width</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span><span class="o">/</span><span class="nx">width</span> <span class="o">&gt;</span> <span class="mf">0.1</span> <span class="err">\</span><span class="o">|</span><span class="err">\</span><span class="o">|</span> <span class="nx">abs</span><span class="p">(</span><span class="nx">yPos</span> <span class="o">-</span> <span class="nx">height</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span><span class="o">/</span><span class="nx">height</span> <span class="o">&gt;</span> <span class="mf">0.1</span> <span class="p">)</span> <span class="p">{</span>
    <span class="c1">// Draws a red curcle if it's less than 10% of the width/height of the frame</span>
    <span class="nx">fill</span><span class="p">(</span><span class="nx">color</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">256</span><span class="p">));</span>   <span class="c1">// Set shape filling color to blue</span>
  <span class="p">}</span> <span class="k">else</span>  <span class="p">{</span>
    <span class="c1">// Otherwise set to filling color to green</span>
    <span class="nx">fill</span><span class="p">(</span><span class="nx">color</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">256</span><span class="p">,</span><span class="mi">0</span><span class="p">));</span>
  <span class="p">}</span>
  <span class="c1">// Draw a circle based on joystick movement</span>
  <span class="nx">circle</span><span class="p">(</span><span class="nx">xPos</span><span class="p">,</span> <span class="nx">yPos</span><span class="p">,</span> <span class="nx">diameter</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// Draw function: pass data to draw the sphere</span>
<span class="kd">function</span> <span class="nx">draw</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">x</span> <span class="o">=</span> <span class="nx">dataarray</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
  <span class="kd">let</span> <span class="nx">y</span> <span class="o">=</span> <span class="nx">dataarray</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
  <span class="nx">drawSphere</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// Event listener: Waits for key press </span>
<span class="kd">function</span> <span class="nx">keyPressed</span><span class="p">()</span> <span class="p">{</span>
	<span class="c1">// Write the pressed key to serial (Arduino)</span>
	<span class="nx">serial</span><span class="p">.</span><span class="nx">write</span><span class="p">(</span><span class="nx">key</span><span class="p">);</span>
<span class="p">}</span></code></pre></figure>]]></content><author><name></name></author><category term="jekyll" /><category term="update" /><summary type="html"><![CDATA[Demo Sending joystick data to webpage &amp; receiving keyboard input from browser Demo video showing the joystick controlling a ball on screen that changes color depending on its distance from the boarder of the frame. The LCD connected to Arduino prints out keystrokes entered on the webpage.]]></summary></entry><entry><title type="html">Assignment 5: Higher Voltage and Transistors!</title><link href="http://localhost:4000/hcde439/jekyll/update/2023/02/18/Assignment-5-Higher-Voltage-and-Transistors.html" rel="alternate" type="text/html" title="Assignment 5: Higher Voltage and Transistors!" /><published>2023-02-18T23:20:00-08:00</published><updated>2023-02-18T23:20:00-08:00</updated><id>http://localhost:4000/hcde439/jekyll/update/2023/02/18/Assignment%205%20Higher%20Voltage%20and%20Transistors</id><content type="html" xml:base="http://localhost:4000/hcde439/jekyll/update/2023/02/18/Assignment-5-Higher-Voltage-and-Transistors.html"><![CDATA[<h2 id="demo">Demo</h2>
<p><strong>Controlling LED strip with IR remote</strong><br />
Demo video for LED strip controlled by IR remote.
<img src="/hcde439/assets/hw5_demo.gif" alt="Demo video showing LED strip controlled by IR remote" width="75%" /></p>

<h2 id="circuit-drawing">Circuit drawing</h2>
<p>The IR receiver is connected to the microcontroller’s digital pins. The LED strip is connected to 12V power and is controlled by the transistor connected to Arduino’s digital output pin &amp; ground.
<img src="/hcde439/assets/hw5_circuit.png" alt="Circuit drawing" width="80%" /></p>

<p>The IR receiver is powered by the 5V pin on the microcontroller, and the LED strip is powered by an external power supply instead. By looking at the labels, I was able to determine that the light strip is rated at 12V and 1.5A which is within the PSU’s capacity of supplying 12V and 2A. The current drawn by the LED strip is also within the rated maximum drain current of 32A (at 25°C) for the FQP30N06L-ND transistor.</p>

<p><img src="/hcde439/assets/hw5_circuit_photo.png" alt="Circuit photo" width="80%" /></p>

<h2 id="arduino-code">Arduino code</h2>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="c1">// Include external libraries</span>
<span class="cp">#include</span> <span class="cpf">&lt;Arduino.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;IRremote.hpp&gt;</span><span class="cp">
</span>
<span class="c1">// Preprocessor macros for input and output pin etc.</span>
<span class="cp">#define IR_RECEIVE_PIN 11  // IR receiver pin
#define DECODE_NEC        // Use NEC decode for IR signal
</span>
<span class="cp">#define LED_PIN 6 // LED pin
</span>
<span class="c1">// State variable: LED brightness</span>
<span class="kt">uint8_t</span> <span class="n">led_brightness</span> <span class="o">=</span> <span class="mi">25</span><span class="p">;</span>
<span class="c1">// State variable: LED is on/off</span>
<span class="n">bool</span> <span class="n">led_on</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
<span class="c1">// Tracks if the power button was pressed</span>
<span class="n">bool</span> <span class="n">button_down</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
<span class="c1">// Tracks the time of last button press</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">last_btn_press</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="c1">// Setup code, run once</span>
<span class="kt">void</span> <span class="nf">setup</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// Initialize Serial communications</span>
  <span class="n">Serial</span><span class="p">.</span><span class="n">begin</span><span class="p">(</span><span class="mi">9600</span><span class="p">);</span>
  <span class="c1">// Set LED to output mode</span>
  <span class="n">pinMode</span><span class="p">(</span><span class="n">LED_PIN</span><span class="p">,</span> <span class="n">OUTPUT</span><span class="p">);</span>
  <span class="c1">// Start the receiver and if not 3 parameter specified, take LED_BUILTIN pin from the internal boards definition as default feedback LED</span>
  <span class="n">IrReceiver</span><span class="p">.</span><span class="n">begin</span><span class="p">(</span><span class="n">IR_RECEIVE_PIN</span><span class="p">,</span> <span class="n">ENABLE_LED_FEEDBACK</span><span class="p">);</span>
  <span class="c1">// Print ready prompt to terminal</span>
  <span class="n">Serial</span><span class="p">.</span><span class="n">print</span><span class="p">(</span><span class="n">F</span><span class="p">(</span><span class="s">"Ready to receive IR signals of protocols: "</span><span class="p">));</span>
  <span class="n">printActiveIRProtocols</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Serial</span><span class="p">);</span>    <span class="c1">// Print active IR protocol used</span>
<span class="p">}</span>

<span class="c1">// Interactive code, infinite loop</span>
<span class="kt">void</span> <span class="nf">loop</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// Check for received data &amp; attempt to decode</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">IrReceiver</span><span class="p">.</span><span class="n">decode</span><span class="p">())</span> <span class="p">{</span>
    <span class="c1">// Process if the received </span>
    <span class="k">if</span><span class="p">(</span><span class="n">IrReceiver</span><span class="p">.</span><span class="n">decodedIRData</span><span class="p">.</span><span class="n">protocol</span> <span class="o">==</span> <span class="n">NEC</span><span class="p">){</span>
      <span class="c1">// IrReceiver.decodedIRData.command</span>
      <span class="c1">// Print raw IR data to terminal</span>
      <span class="n">Serial</span><span class="p">.</span><span class="n">println</span><span class="p">(</span><span class="n">IrReceiver</span><span class="p">.</span><span class="n">decodedIRData</span><span class="p">.</span><span class="n">command</span><span class="p">);</span>
      <span class="c1">// Switch statements is used to handle different button presses</span>
      <span class="k">switch</span><span class="p">(</span><span class="n">IrReceiver</span><span class="p">.</span><span class="n">decodedIRData</span><span class="p">.</span><span class="n">command</span><span class="p">){</span>
        <span class="k">case</span> <span class="mi">12</span><span class="p">:</span>  <span class="c1">// User pressed 1</span>
          <span class="n">led_brightness</span> <span class="o">=</span> <span class="mi">25</span><span class="p">;</span> <span class="c1">// lower brightness</span>
          <span class="k">break</span><span class="p">;</span>
        <span class="k">case</span> <span class="mi">24</span><span class="p">:</span>  <span class="c1">// User pressed 2</span>
          <span class="n">led_brightness</span> <span class="o">=</span> <span class="mi">90</span><span class="p">;</span> <span class="c1">// higher brightness</span>
          <span class="k">break</span><span class="p">;</span>
        <span class="k">case</span> <span class="mi">69</span><span class="p">:</span>  <span class="c1">// User pressed power button</span>
          <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">button_down</span><span class="p">){</span>  <span class="c1">// If power button wasn't already pressed</span>
            <span class="n">led_on</span> <span class="o">=</span> <span class="o">!</span><span class="n">led_on</span><span class="p">;</span> <span class="c1">// Toggle led state</span>
            <span class="n">button_down</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>   <span class="c1">// Set power button as pressed</span>
          <span class="p">}</span>
          <span class="k">break</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="c1">// Update last_btn_press to reflect most recent button press</span>
      <span class="n">last_btn_press</span> <span class="o">=</span> <span class="n">millis</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="c1">// Resume IR data receive</span>
    <span class="n">IrReceiver</span><span class="p">.</span><span class="n">resume</span><span class="p">();</span> <span class="c1">// Enable receiving of the next value</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>  <span class="c1">// IR info not decoded correctly</span>
    <span class="c1">// Reset button state of the last press was more than 200ms ago</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">millis</span><span class="p">()</span><span class="o">-</span><span class="n">last_btn_press</span> <span class="o">&gt;</span> <span class="mi">200</span><span class="p">)</span>
      <span class="n">button_down</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="c1">// Debug prints</span>
  <span class="c1">// Prints expected led state &amp; brightness to terminal via serial</span>
  <span class="n">Serial</span><span class="p">.</span><span class="n">print</span><span class="p">(</span><span class="n">led_on</span><span class="p">);</span>
  <span class="n">Serial</span><span class="p">.</span><span class="n">print</span><span class="p">(</span><span class="s">"   "</span><span class="p">);</span>
  <span class="n">Serial</span><span class="p">.</span><span class="n">println</span><span class="p">(</span><span class="n">led_brightness</span><span class="p">);</span>
  <span class="c1">// If LED is supposed to be on</span>
  <span class="k">if</span><span class="p">(</span><span class="n">led_on</span><span class="p">){</span> 
    <span class="n">analogWrite</span><span class="p">(</span><span class="n">LED_PIN</span><span class="p">,</span> <span class="n">led_brightness</span><span class="p">);</span> <span class="c1">// Set LED to specified brightness</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>  <span class="c1">// Otherwise it's supposed to be off</span>
    <span class="n">digitalWrite</span><span class="p">(</span><span class="n">LED_PIN</span><span class="p">,</span> <span class="n">LOW</span><span class="p">);</span><span class="c1">// Turn off LED</span>
  <span class="p">}</span>
  <span class="c1">// Program loop delay</span>
  <span class="n">delay</span><span class="p">(</span><span class="mi">20</span><span class="p">);</span>
<span class="p">}</span></code></pre></figure>]]></content><author><name></name></author><category term="jekyll" /><category term="update" /><summary type="html"><![CDATA[Demo Controlling LED strip with IR remote Demo video for LED strip controlled by IR remote.]]></summary></entry><entry><title type="html">Assignment 4: Libraries!</title><link href="http://localhost:4000/hcde439/jekyll/update/2023/02/12/Assignment-4-Libraries!.html" rel="alternate" type="text/html" title="Assignment 4: Libraries!" /><published>2023-02-12T23:26:00-08:00</published><updated>2023-02-12T23:26:00-08:00</updated><id>http://localhost:4000/hcde439/jekyll/update/2023/02/12/Assignment%204%20Libraries!</id><content type="html" xml:base="http://localhost:4000/hcde439/jekyll/update/2023/02/12/Assignment-4-Libraries!.html"><![CDATA[<h2 id="demo">Demo</h2>
<p><strong>Control 8-segement display with IR remote</strong><br />
Demo video for 8-segment display controlled by IR remote.
<img src="/hcde439/assets/hw4_demo.gif" alt="Demo video showing 8-segment display controlled by IR remote" width="75%" /></p>

<h2 id="circuit-drawing">Circuit drawing</h2>
<p>The IR receiver &amp; 7-segment display are connected to the microcontroller’s output pins. Resistors are connected in series with the 7-segment display to limit current.
<img src="/hcde439/assets/hw4_circuit.png" alt="Circuit drawing" width="80%" /></p>

<p>The circuit is is powered via USB connected to the Arudino microcontroller.</p>

<p><img src="/hcde439/assets/hw4_circuit_photo.png" alt="Circuit photo" width="80%" /></p>

<h2 id="calculating-resistor-values">Calculating resistor values</h2>

<h3 id="7-segment-display-led-resistor">7-segment display LED resistor</h3>

<p>Because each red LED that makes up the 7 segments can operate safely within $\leq 30 \text{mA}$ of current, we need to use resisters to reduce the amount of current going through each LED.</p>

<p>Since we are connecting the resister &amp; the LED in series, the amount of current through the LED is the same as that for the resister ($I_\text{L} = I_\text{r}$). This also means that the sum of voltage drop across the resister and LED should be equal to the voltage provided by the Arduino microcontroller (5V).</p>

<p>With these information, we calculate the minimum resistance by applying Ohm’s law on the resister.
$$
\begin{align*}
  V_\text{r} &amp;= I_\text{r} R_\text{r} &amp;&amp; \text{Ohm’s law}\cr
  V_\text{PSU} - V_\text{L} &amp;= I_\text{L} R_\text{r} &amp;&amp;\text{Substitute resister V &amp; I}\cr
  5\texttt{V} - V_\text{L} &amp;= 20\texttt{mA} \cdot R_\text{r}\cr
\end{align*}
$$</p>

<p>A <strong>220 Ω</strong> resister is used for the red LEDs because these LEDs have a voltage drop of 1.7V. Their resisters’ resistance to be at least
$$
\begin{align*}
  V&amp;=IR\cr
  5\;\texttt{V} - 1.7\;\texttt{V} &amp;=20\;\texttt{mA} \cdot \textrm{R}\cr
  \frac{3.3\;\texttt{V}}{0.02\;\texttt{A}} &amp;= \textrm{R}\cr
  \textrm{R} &amp;= 165 \;\Omega
\end{align*}
$$</p>

<p>Using a resistor with higher resistance than what is required here will not have an adverse effect on the longevity of the LED, it will simply cause it to appear a bit dimmer.</p>

<h2 id="arduino-code">Arduino code</h2>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="c1">// Include external libraries</span>
<span class="cp">#include</span> <span class="cpf">&lt;Arduino.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;IRremote.hpp&gt;</span><span class="c1">   // IR receiver library</span><span class="cp">
#include</span> <span class="cpf">&lt;SevenSegmentDisplay.h&gt;</span><span class="c1">  // 7-segment display library</span><span class="cp">
</span>
<span class="c1">// Preprocessor macros for input and output pin etc.</span>
<span class="cp">#define IR_RECEIVE_PIN 2  // IR receiver pin
#define DECODE_NEC        // Use NEC decode for IR signal
</span>
<span class="c1">// Define LED pins for each LED in 7-segment display</span>
<span class="cp">#define PIN_DP 5
#define PIN_C 12
#define PIN_D 11
#define PIN_E 10
#define PIN_B 9
#define PIN_A 8
#define PIN_F 7
#define PIN_G 6
</span>
<span class="c1">// Define number of LEDs</span>
<span class="cp">#define NUM_LEDS 8
</span>
<span class="c1">// Array of LED pins</span>
<span class="kt">uint8_t</span> <span class="n">LEDs</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="n">PIN_DP</span><span class="p">,</span> <span class="n">PIN_C</span><span class="p">,</span> <span class="n">PIN_D</span><span class="p">,</span> <span class="n">PIN_E</span><span class="p">,</span> <span class="n">PIN_B</span><span class="p">,</span> <span class="n">PIN_A</span><span class="p">,</span> <span class="n">PIN_F</span><span class="p">,</span> <span class="n">PIN_G</span> <span class="p">};</span>

<span class="c1">// Shared int pointer for loops</span>
<span class="kt">uint8_t</span><span class="o">*</span> <span class="n">ptr</span><span class="p">;</span>

<span class="c1">// Variable to store decoded button value</span>
<span class="c1">// val == -1 if the button is not a number</span>
<span class="kt">uint8_t</span> <span class="n">val</span><span class="p">;</span>

<span class="c1">// Define a seven segment display</span>
<span class="n">SevenSegmentDisplay</span> <span class="nf">screen</span><span class="p">(</span><span class="n">PIN_A</span><span class="p">,</span> <span class="n">PIN_B</span><span class="p">,</span> <span class="n">PIN_C</span><span class="p">,</span> <span class="n">PIN_D</span><span class="p">,</span> <span class="n">PIN_E</span><span class="p">,</span> <span class="n">PIN_F</span><span class="p">,</span><span class="n">PIN_G</span><span class="p">,</span> <span class="n">PIN_DP</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>

<span class="c1">// Setup code, run once</span>
<span class="kt">void</span> <span class="nf">setup</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// Initialize Serial communications</span>
  <span class="n">Serial</span><span class="p">.</span><span class="n">begin</span><span class="p">(</span><span class="mi">9600</span><span class="p">);</span>
  <span class="c1">// Initialize all LED pins to output mode</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">LEDs</span><span class="p">;</span> <span class="n">ptr</span> <span class="o">&lt;</span> <span class="n">LEDs</span> <span class="o">+</span> <span class="n">NUM_LEDS</span><span class="p">;</span> <span class="o">++</span><span class="n">ptr</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">pinMode</span><span class="p">(</span><span class="o">*</span><span class="n">ptr</span><span class="p">,</span> <span class="n">OUTPUT</span><span class="p">);</span>  <span class="c1">// Set a single pin to output mode</span>
  <span class="p">}</span>
  <span class="c1">// Start the receiver and if not 3 parameter specified, take LED_BUILTIN pin from the internal boards definition as default feedback LED</span>
  <span class="n">IrReceiver</span><span class="p">.</span><span class="n">begin</span><span class="p">(</span><span class="n">IR_RECEIVE_PIN</span><span class="p">,</span> <span class="n">ENABLE_LED_FEEDBACK</span><span class="p">);</span>
  <span class="c1">// Print ready prompt to terminal</span>
  <span class="n">Serial</span><span class="p">.</span><span class="n">print</span><span class="p">(</span><span class="n">F</span><span class="p">(</span><span class="s">"Ready to receive IR signals of protocols: "</span><span class="p">));</span>
  <span class="n">printActiveIRProtocols</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Serial</span><span class="p">);</span>    <span class="c1">// Print active IR protocol used</span>
<span class="p">}</span>


<span class="c1">// Interactive code, infinite loop</span>
<span class="kt">void</span> <span class="nf">loop</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// Check for received data &amp; attempt to decode</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">IrReceiver</span><span class="p">.</span><span class="n">decode</span><span class="p">())</span> <span class="p">{</span>
    <span class="c1">// Process if the received </span>
    <span class="k">if</span><span class="p">(</span><span class="n">IrReceiver</span><span class="p">.</span><span class="n">decodedIRData</span><span class="p">.</span><span class="n">protocol</span> <span class="o">==</span> <span class="n">NEC</span><span class="p">){</span>
      <span class="c1">// Attempt to match the received command into a number button</span>
      <span class="c1">// If a received command can be mapped to a number on the remote,</span>
      <span class="c1">// set val to that number</span>
      <span class="k">switch</span><span class="p">(</span><span class="n">IrReceiver</span><span class="p">.</span><span class="n">decodedIRData</span><span class="p">.</span><span class="n">command</span><span class="p">){</span>
        <span class="k">case</span> <span class="mh">0x16</span><span class="p">:</span>  <span class="c1">// Case for button 0</span>
          <span class="n">val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
          <span class="k">break</span><span class="p">;</span>
        <span class="k">case</span> <span class="mh">0xC</span><span class="p">:</span>   <span class="c1">// Case for button 1</span>
          <span class="n">val</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
          <span class="k">break</span><span class="p">;</span>
        <span class="k">case</span> <span class="mh">0x18</span><span class="p">:</span>  <span class="c1">// .....</span>
          <span class="n">val</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
          <span class="k">break</span><span class="p">;</span>
        <span class="k">case</span> <span class="mh">0x5E</span><span class="p">:</span>
          <span class="n">val</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
          <span class="k">break</span><span class="p">;</span>
        <span class="k">case</span> <span class="mh">0x8</span><span class="p">:</span>
          <span class="n">val</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
          <span class="k">break</span><span class="p">;</span>
        <span class="k">case</span> <span class="mh">0x1C</span><span class="p">:</span>
          <span class="n">val</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
          <span class="k">break</span><span class="p">;</span>
        <span class="k">case</span> <span class="mh">0x5A</span><span class="p">:</span>
          <span class="n">val</span> <span class="o">=</span> <span class="mi">6</span><span class="p">;</span>
          <span class="k">break</span><span class="p">;</span>
        <span class="k">case</span> <span class="mh">0x42</span><span class="p">:</span>
          <span class="n">val</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span>
          <span class="k">break</span><span class="p">;</span>
        <span class="k">case</span> <span class="mh">0x52</span><span class="p">:</span>
          <span class="n">val</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>
          <span class="k">break</span><span class="p">;</span>
        <span class="k">case</span> <span class="mh">0x4A</span><span class="p">:</span>  <span class="c1">// Case for button 9</span>
          <span class="n">val</span> <span class="o">=</span> <span class="mi">9</span><span class="p">;</span>
          <span class="k">break</span><span class="p">;</span>
        <span class="nl">default:</span>  <span class="c1">// Default case: handles other buttons</span>
          <span class="n">val</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="c1">// Only update the seven segement display if button was a number</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">){</span>
        <span class="c1">// Update the 7 segment display</span>
        <span class="n">screen</span><span class="p">.</span><span class="n">displayCharacter</span><span class="p">(</span><span class="n">val</span> <span class="o">+</span> <span class="sc">'0'</span><span class="p">);</span>
        <span class="c1">// Print raw IR data to terminal</span>
        <span class="n">Serial</span><span class="p">.</span><span class="n">println</span><span class="p">(</span><span class="n">IrReceiver</span><span class="p">.</span><span class="n">decodedIRData</span><span class="p">.</span><span class="n">decodedRawData</span><span class="p">);</span>
      <span class="p">}</span>
    <span class="p">}</span>
    <span class="c1">// Resume IR data receive</span>
    <span class="n">IrReceiver</span><span class="p">.</span><span class="n">resume</span><span class="p">();</span> <span class="c1">// Enable receiving of the next value</span>
  <span class="p">}</span>
  <span class="c1">// Program loop delay</span>
  <span class="n">delay</span><span class="p">(</span><span class="mi">20</span><span class="p">);</span>
<span class="p">}</span></code></pre></figure>]]></content><author><name></name></author><category term="jekyll" /><category term="update" /><summary type="html"><![CDATA[Demo Control 8-segement display with IR remote Demo video for 8-segment display controlled by IR remote.]]></summary></entry><entry><title type="html">Assignment 3: I/O (Input/Output)!</title><link href="http://localhost:4000/hcde439/jekyll/update/2023/01/28/Assignment-3-IO.html" rel="alternate" type="text/html" title="Assignment 3: I/O (Input/Output)!" /><published>2023-01-28T17:23:00-08:00</published><updated>2023-01-28T17:23:00-08:00</updated><id>http://localhost:4000/hcde439/jekyll/update/2023/01/28/Assignment%203%20IO</id><content type="html" xml:base="http://localhost:4000/hcde439/jekyll/update/2023/01/28/Assignment-3-IO.html"><![CDATA[<h2 id="demo">Demo</h2>
<p><strong>Sensor calibration</strong><br />
Demo video showing initial sensor calibration on startup. When both LEDs are on, capture the minimum reading from sensor. When both LEDs are off, capture the maximum reading from sensor. Both LEDs flashing together indicates calibration completion.<br />
<img src="/hcde439/assets/hw3_calib.gif" alt="Demo video showing initial sensor calibration on startup" width="75%" /></p>

<p><strong>Adjusting brightness</strong><br />
Demo showing the potentiometer controlling LED brightness in opposite directions. Turning the knob counterclockwise increases brightness for the top LED and dims the bottom LED. Turning the knob clockwise dims the top LED and increases power (brightness) for the top LED.<br />
<img src="/hcde439/assets/hw3_adjust.gif" alt="Demo video for adjusting LED brightness" width="75%" /></p>

<p><strong>Serial communications</strong><br />
Screen capture of data being sent over a serial connection upon initial startup &amp; regular operation.<br />
<img src="/hcde439/assets/hw3_terminal.gif" alt="Screen capture of data being sent over serial connection" width="80%" /></p>

<h2 id="circuit-drawing">Circuit drawing</h2>
<p><img src="/hcde439/assets/hw3_circuit.png" alt="Circuit drawing" width="80%" /></p>

<p>The circuit is is powered via USB connected to the Arudino microcontroller. The blue LEDs are connected to pin 3 and 9 respectively. Each LED is connected in series with a 220 Ω resistor to reduce the current through the LED.</p>

<p>The circuit also contains a potentiometer. It is connected to pin A0 and a 330 Ω resister (equivalent of a voltmeter) to limit current through the system.</p>

<p><img src="/hcde439/assets/hw3_circuit_photo.png" alt="Circuit photo" width="80%" /></p>

<h2 id="calculating-resistor-values">Calculating resistor values</h2>

<h3 id="led-resistor">LED resistor</h3>

<p>Because each LED used in this assignment can operate safely with $\leq 30 \text{mA}$ of current, we need to use resisters to reduce the amount of current going through each LED.</p>

<p>Since we are connecting the resister &amp; the LED in series, the amount of current through the LED is the same as that for the resister ($I_\text{L} = I_\text{r}$). This also means that the sum of voltage drop across the resister and LED should be equal to the voltage provided by the Arduino microcontroller (5V).</p>

<p>With these information, we calculate the minimum resistance by applying Ohm’s law on the resister.
$$
\begin{align*}
  V_\text{r} &amp;= I_\text{r} R_\text{r} &amp;&amp; \text{Ohm’s law}\cr
  V_\text{PSU} - V_\text{L} &amp;= I_\text{L} R_\text{r} &amp;&amp;\text{Substitute resister V &amp; I}\cr
  5\texttt{V} - V_\text{L} &amp;= 20\texttt{mA} \cdot R_\text{r}\cr
\end{align*}
$$</p>

<p>A <strong>220 Ω</strong> resister is used for the blue LED (voltage drop = 3.3V). It needs an resistor that is at least
$$
\begin{align*}
    V&amp;=IR\cr
    5\;\texttt{V} - 3.3\;\texttt{V} &amp;=20\;\texttt{mA} \cdot \textrm{R}\cr
    \frac{1.7\;\texttt{V}}{0.02\;\texttt{A}} &amp;= \textrm{R}\cr
    \textrm{R} &amp;= 85 \;\Omega
\end{align*}
$$
Using a resistor with higher resistance than what is required here (e.g. a 100 Ω resistor) will not have an adverse effect on the longevity of the LED, it will simply cause it to appear a bit dimmer.</p>

<h3 id="potentiometer-resistor">Potentiometer resistor</h3>
<p>Assuming the analog in port on Arudino is an ideal voltmeter (aka. infinite resistance), the resistor and the potentiometer are effectively connected in series. Because the maximum DC current through the GND pin for the microcontroller is 200 mA, we also need to calculate the minimum resistence for the previously mentioned resistor. Since the ground pin is shared between the LEDs and the potentiometer, we need to consider the worst case scenario where current through the circuit is maximized when the potentiometer’s resistance is approximately 0 Ω and both LEDs are on. We first calculate the current through the LEDs.</p>

<p>$$
\begin{align*}
  V &amp;= IR &amp;&amp;\text{Ohm’s law}\cr
  I &amp;= \frac{V}{R}\cr
  I &amp;= \frac{5\texttt{V}-3.3\texttt{V}}{220\Omega} &amp;&amp;\text{Substitution}\cr
  I &amp;\approx 7.8 mA &amp;&amp;\text{Round up for worst-case scenario}
\end{align*}
$$</p>

<p>Because each LED and the potentio meter are connected in parallel, we can then determine that</p>

<p>$$
\begin{align*}
  I_\text{max} &amp;&gt; I_\text{LED} \cdot 2 + I_\text{pot}\cr
  200 \texttt{mA} &amp;&gt; 7.8 \texttt{mA} \cdot 2 + I_\text{pot}\cr
  I_\text{pot} &amp;&lt; 184.4 \texttt{mA}
\end{align*}
$$</p>

<p>In the worst case with potentiometer having 0 Ω, the minimum resistance for the other resistor is:
$$
\begin{align*}
   V &amp;= I R &amp;&amp; \text{Ohm’s law}\cr
   5 \texttt{V} &amp;= 184.4 \texttt{mA} \cdot R &amp;&amp;\text{Substitue V &amp; I}\cr
   R &amp;= \frac{5\texttt{V}}{0.1844\texttt{A}}\cr
   R &amp;\approx 28 \;\Omega
\end{align*}
$$</p>

<p>Considering that other on-board devices might be sharing the ground pin under the hood, I decided to be extra cautious and use a <strong>330 Ω</strong>  resistor.</p>

<h2 id="arduino-code">Arduino code</h2>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="c1">// Preprocessor macros</span>
<span class="cp">#define LED1_PIN 3  // Bottom LED
#define LED2_PIN 9  // Top LED
#define NUM_LEDS 2  // # of LEDs
</span>
<span class="cp">#define SENSOR_PIN A0 // Analog sensor port (potentiometer)
</span>

<span class="c1">// Global variables</span>
<span class="c1">// Loop variable</span>
<span class="kt">uint8_t</span> <span class="n">i</span><span class="p">;</span>
<span class="c1">// Temporarily saves sensor readings</span>
<span class="kt">long</span> <span class="n">sensor_val</span><span class="p">;</span>
<span class="c1">// Stores sensor reading for reuse</span>
<span class="kt">long</span> <span class="n">sensor_max</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>    <span class="c1">// Initial max sensor value</span>
<span class="kt">long</span> <span class="n">sensor_min</span> <span class="o">=</span> <span class="mi">1023</span><span class="p">;</span> <span class="c1">// Initial min sensor value</span>

<span class="c1">// Array of LEDs in the system</span>
<span class="kt">uint8_t</span> <span class="n">LEDs</span><span class="p">[</span><span class="n">NUM_LEDS</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="n">LED1_PIN</span><span class="p">,</span> <span class="n">LED2_PIN</span><span class="p">};</span>


<span class="c1">// Helper functions</span>
<span class="c1">// Synchronize all LEDs to either ON or OFF state</span>
<span class="kt">void</span> <span class="nf">sync_led</span><span class="p">(</span><span class="kt">uint8_t</span><span class="o">*</span> <span class="n">L</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="n">num</span><span class="p">,</span> <span class="n">bool</span> <span class="n">state</span><span class="p">);</span>


<span class="c1">// Setup code, run once</span>
<span class="kt">void</span> <span class="nf">setup</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// Set all used pins to output mode</span>
  <span class="n">pinMode</span><span class="p">(</span><span class="n">LED1_PIN</span><span class="p">,</span> <span class="n">OUTPUT</span><span class="p">);</span>  <span class="c1">// Set top LED to output mode</span>
  <span class="n">pinMode</span><span class="p">(</span><span class="n">LED2_PIN</span><span class="p">,</span> <span class="n">OUTPUT</span><span class="p">);</span>  <span class="c1">// Set bottom LED to output mode</span>
  <span class="n">Serial</span><span class="p">.</span><span class="n">begin</span><span class="p">(</span><span class="mi">9600</span><span class="p">);</span>         <span class="c1">// Set up serial connection</span>

  <span class="c1">// Calibrate min input</span>
  <span class="c1">// Light up all LEDs to indicate the system is measuring min input</span>
  <span class="n">sync_led</span><span class="p">(</span><span class="n">LEDs</span><span class="p">,</span> <span class="n">NUM_LEDS</span><span class="p">,</span> <span class="n">HIGH</span><span class="p">);</span>
  <span class="c1">// Print text to terminal</span>
  <span class="n">Serial</span><span class="p">.</span><span class="n">print</span><span class="p">(</span><span class="s">"Calibrating min:</span><span class="se">\t</span><span class="s">"</span><span class="p">);</span>

  <span class="c1">// Take 10 measurements</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">){</span>
    <span class="n">sensor_val</span> <span class="o">=</span> <span class="n">analogRead</span><span class="p">(</span><span class="n">SENSOR_PIN</span><span class="p">);</span>  <span class="c1">// Save reading to temp variable</span>
    <span class="c1">// Update minimum if the measured value is less than the known minimum</span>
    <span class="k">if</span><span class="p">(</span><span class="n">sensor_val</span> <span class="o">&lt;</span> <span class="n">sensor_min</span><span class="p">)</span>
      <span class="n">sensor_min</span> <span class="o">=</span> <span class="n">sensor_val</span><span class="p">;</span>
    
    <span class="n">Serial</span><span class="p">.</span><span class="n">print</span><span class="p">(</span><span class="n">sensor_min</span><span class="p">);</span> <span class="c1">// Print the obtained value</span>
    <span class="n">Serial</span><span class="p">.</span><span class="n">print</span><span class="p">(</span><span class="sc">'\t'</span><span class="p">);</span>       <span class="c1">// insert tab character for spacing</span>
    <span class="c1">// Delay to allow the user some time to generate the min sensor reading</span>
    <span class="n">delay</span><span class="p">(</span><span class="mi">300</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="c1">// Print out the finalized min sensor reading</span>
  <span class="n">Serial</span><span class="p">.</span><span class="n">print</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">Finalized min:</span><span class="se">\t</span><span class="s">"</span><span class="p">);</span>
  <span class="n">Serial</span><span class="p">.</span><span class="n">println</span><span class="p">(</span><span class="n">sensor_min</span><span class="p">);</span>

  <span class="c1">// Calibrate max input</span>
  <span class="c1">// Turn all LEDs off to indicate the system is measuring max input</span>
  <span class="n">sync_led</span><span class="p">(</span><span class="n">LEDs</span><span class="p">,</span> <span class="n">NUM_LEDS</span><span class="p">,</span> <span class="n">LOW</span><span class="p">);</span>
  <span class="c1">// Print text to terminal</span>
  <span class="n">Serial</span><span class="p">.</span><span class="n">print</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">Calibrating max:</span><span class="se">\t</span><span class="s">"</span><span class="p">);</span>

  <span class="c1">// Take 10 measurements</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">){</span>
    <span class="n">sensor_val</span> <span class="o">=</span> <span class="n">analogRead</span><span class="p">(</span><span class="n">SENSOR_PIN</span><span class="p">);</span>    <span class="c1">// Save reading to temp variable</span>
    <span class="c1">// Update maximum if the measured value is greater than the known maximum</span>
    <span class="k">if</span><span class="p">(</span><span class="n">sensor_val</span> <span class="o">&gt;</span> <span class="n">sensor_max</span><span class="p">)</span>
      <span class="n">sensor_max</span> <span class="o">=</span> <span class="n">sensor_val</span><span class="p">;</span>  <span class="c1">// Print the obtained value</span>
    
    <span class="n">Serial</span><span class="p">.</span><span class="n">print</span><span class="p">(</span><span class="n">sensor_max</span><span class="p">);</span>   <span class="c1">// insert tab character for spacing</span>
    <span class="n">Serial</span><span class="p">.</span><span class="n">print</span><span class="p">(</span><span class="sc">'\t'</span><span class="p">);</span>         <span class="c1">// insert tab character for spacing</span>
    <span class="c1">// Delay to allow the user some time to generate the min sensor reading</span>
    <span class="n">delay</span><span class="p">(</span><span class="mi">300</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="c1">// Print out the finalized max sensor reading</span>
  <span class="n">Serial</span><span class="p">.</span><span class="n">print</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">Finalized max:</span><span class="se">\t</span><span class="s">"</span><span class="p">);</span>
  <span class="n">Serial</span><span class="p">.</span><span class="n">println</span><span class="p">(</span><span class="n">sensor_max</span><span class="p">);</span>

  <span class="c1">// Blink the LEDs for a few times to indicate end of calibration</span>
  <span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">){</span> <span class="c1">// Loop</span>
    <span class="n">sync_led</span><span class="p">(</span><span class="n">LEDs</span><span class="p">,</span> <span class="n">NUM_LEDS</span><span class="p">,</span> <span class="n">i</span> <span class="o">%</span> <span class="mi">2</span><span class="p">);</span>  <span class="c1">// Change LED state on every iteration</span>
    <span class="n">delay</span><span class="p">(</span><span class="mi">300</span><span class="p">);</span> <span class="c1">// Delay to make the blinking noticable</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// Infinite loop: Interactive code</span>
<span class="kt">void</span> <span class="nf">loop</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// Read from potentiometer value</span>
  <span class="n">sensor_val</span> <span class="o">=</span> <span class="n">analogRead</span><span class="p">(</span><span class="n">SENSOR_PIN</span><span class="p">);</span>

  <span class="c1">// Prints raw value from the potentiometer</span>
  <span class="n">Serial</span><span class="p">.</span><span class="n">print</span><span class="p">(</span><span class="s">"Raw sensor reading: "</span><span class="p">);</span>
  <span class="n">Serial</span><span class="p">.</span><span class="n">println</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>

  <span class="c1">// Limit sensor value to prevent overflow (after mapping to LED range)</span>
  <span class="n">sensor_val</span> <span class="o">=</span> <span class="n">constrain</span><span class="p">(</span><span class="n">sensor_val</span><span class="p">,</span> <span class="n">sensor_min</span><span class="p">,</span> <span class="n">sensor_max</span><span class="p">);</span>

  <span class="c1">// Map sensor reading to bottom LED</span>
  <span class="n">analogWrite</span><span class="p">(</span><span class="n">LED1_PIN</span><span class="p">,</span> <span class="n">map</span><span class="p">(</span><span class="n">sensor_val</span><span class="p">,</span> <span class="n">sensor_min</span><span class="p">,</span> <span class="n">sensor_max</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">));</span>
  <span class="c1">// Map sensor reading to top LED (inverse)</span>
  <span class="n">analogWrite</span><span class="p">(</span><span class="n">LED2_PIN</span><span class="p">,</span> <span class="n">map</span><span class="p">(</span><span class="n">sensor_val</span><span class="p">,</span> <span class="n">sensor_min</span><span class="p">,</span> <span class="n">sensor_max</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
  
  <span class="c1">// Add some delay between reads</span>
  <span class="n">delay</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
<span class="p">}</span>


<span class="c1">// Helper function implementation</span>
<span class="c1">// </span>
<span class="cm">/**
 * Synchronize all LEDs to either ON or OFF state
 * 
 * @param l Pointer to array of LEDs (output port)
 * @param num: number of LEDs in array l
 * @param state: either HIGH (1) or LOW (0)
*/</span>
<span class="kt">void</span> <span class="nf">sync_led</span><span class="p">(</span><span class="kt">uint8_t</span><span class="o">*</span> <span class="n">L</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="n">num</span><span class="p">,</span> <span class="n">bool</span> <span class="n">state</span><span class="p">){</span>
  <span class="c1">// Loop through the array</span>
  <span class="k">for</span><span class="p">(</span><span class="kt">uint8_t</span><span class="o">*</span> <span class="n">ptr</span> <span class="o">=</span> <span class="n">L</span><span class="p">;</span> <span class="n">ptr</span> <span class="o">&lt;</span> <span class="n">L</span> <span class="o">+</span> <span class="n">num</span><span class="p">;</span> <span class="o">++</span><span class="n">ptr</span><span class="p">){</span>
    <span class="c1">// Individually toggle the state of each LED</span>
    <span class="n">digitalWrite</span><span class="p">(</span><span class="o">*</span><span class="n">ptr</span><span class="p">,</span> <span class="n">state</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure>]]></content><author><name></name></author><category term="jekyll" /><category term="update" /><summary type="html"><![CDATA[Demo Sensor calibration Demo video showing initial sensor calibration on startup. When both LEDs are on, capture the minimum reading from sensor. When both LEDs are off, capture the maximum reading from sensor. Both LEDs flashing together indicates calibration completion.]]></summary></entry><entry><title type="html">Assignment 2: Fade!</title><link href="http://localhost:4000/hcde439/jekyll/update/2023/01/22/Assignment-2-Fade.html" rel="alternate" type="text/html" title="Assignment 2: Fade!" /><published>2023-01-22T00:21:07-08:00</published><updated>2023-01-22T00:21:07-08:00</updated><id>http://localhost:4000/hcde439/jekyll/update/2023/01/22/Assignment%202:%20Fade</id><content type="html" xml:base="http://localhost:4000/hcde439/jekyll/update/2023/01/22/Assignment-2-Fade.html"><![CDATA[<h2 id="demo">Demo</h2>
<p><img src="/hcde439/assets/hw2_demo_2.gif" alt="Demo video for adjusting LED fade color" width="75%" /></p>

<p>Demo showing bottom LED fading to different color on button press.</p>

<p><img src="/hcde439/assets/hw2_demo_1.gif" alt="Demo video for adjusting LEDs fade duration" width="75%" /></p>

<p>Demo showing top two LEDs’ fading duration changing based on duration of their respective button press duration.</p>

<h2 id="circuit-drawing">Circuit drawing</h2>
<p><img src="/hcde439/assets/hw2_circuit.png" alt="Circuit drawing" width="80%" /></p>

<p>The circuit is is powered via USB connected to the Arudino microcontroller. The blue LEDs at the top are connected to pin 6 and 5 respectively. Each primary color LED that made up the RGB LED is connected to pin 9, 10, 11 for red, green, and blue. Each LED is connected in series with a resistor to reduce the current through the LED.</p>

<p>The circuit also contains 3 push buttons connected to pin 8, 4, and 2. A 10 kΩ resister is connected in parallel to the digital input pins to prevent a short circuit and ensure consisitency when reading from those digital pins.</p>

<p><img src="/hcde439/assets/hw2_circuit_photo.jpeg" alt="Circuit photo" width="80%" /></p>

<h2 id="calculating-resistor-values">Calculating resistor values</h2>
<p>Because each LED used in this assignment can operate safely with $\leq 30 \text{mA}$ of current, we need to use resisters to reduce the amount of current going through each LED.</p>

<p>Since we are connecting the resister &amp; the LED in series, the amount of current through the LED is the same as that for the resister ($I_\text{L} = I_\text{r}$). This also means that the sum of voltage drop across the resister and LED should be equal to the voltage provided by the Arduino microcontroller (5V).</p>

<p>With these information, we calculate the minimum resistance by applying Ohm’s law on the resister.
$$
\begin{align*}
  V_\text{r} &amp;= I_\text{r} R_\text{r} &amp;&amp; \text{Ohm’s law}\cr
  V_\text{PSU} - V_\text{L} &amp;= I_\text{L} R_\text{r} &amp;&amp;\text{Substitute resister V &amp; I}\cr
  5\texttt{V} - V_\text{L} &amp;= 20\texttt{mA} \cdot R_\text{r}\cr
\end{align*}
$$</p>

<p>A <strong>220 Ω</strong> resister is used for red and green LEDs because these LEDs have a voltage drop of 1.7V. Their resisters’ resistance to be at least
$$
\begin{align*}
  V&amp;=IR\cr
  5\;\texttt{V} - 1.7\;\texttt{V} &amp;=20\;\texttt{mA} \cdot \textrm{R}\cr
  \frac{3.3\;\texttt{V}}{0.02\;\texttt{A}} &amp;= \textrm{R}\cr
  \textrm{R} &amp;= 165 \;\Omega
\end{align*}
$$</p>

<p>A <strong>220 Ω</strong> resister is used for the blue LED (voltage drop = 3.3V). It needs an resistor that is at least
$$
\begin{align*}
    V&amp;=IR\cr
    5\;\texttt{V} - 3.3\;\texttt{V} &amp;=20\;\texttt{mA} \cdot \textrm{R}\cr
    \frac{1.7\;\texttt{V}}{0.02\;\texttt{A}} &amp;= \textrm{R}\cr
    \textrm{R} &amp;= 85 \;\Omega
\end{align*}
$$
Using a resistor with higher resistance than what is required here (e.g. a 100 Ω resistor) will not have an adverse effect on the longevity of the LED, it will simply cause it to appear a bit dimmer.</p>

<h2 id="arduino-code">Arduino code</h2>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="c1">// Preprocessor marcos</span>
<span class="c1">// Define pins for 3 buttons connected to pin 2, 4, 8</span>
<span class="cp">#define BTN1_PIN 8
#define BTN2_PIN 4
#define BTN3_PIN 2
</span>
<span class="c1">// Define pins for 2 Red LEDs connected to pin 5 &amp; 6</span>
<span class="cp">#define B1_PIN 6
#define B2_PIN 5
</span>
<span class="c1">// Define RGB LED pins</span>
<span class="cp">#define COLOR_R_PIN 9   // Red LED    -&gt; pin 9
#define COLOR_G_PIN 10  // Green LED  -&gt; pin 10  
#define COLOR_B_PIN 11  // Blue LED   -&gt; pin 11
</span>
<span class="c1">// Number of LEDs that can be controlled = 5</span>
<span class="cp">#define NUM_LEDS 5
</span><span class="c1">// Number of buttons connected = 3</span>
<span class="cp">#define NUM_BTNS 3
</span>
<span class="cp">#define ANALOG_MAX 127
#define ANALOG_MIN 0
</span>

<span class="c1">// Global Variables</span>
<span class="c1">// Represents the state of a single LED</span>
<span class="k">struct</span> <span class="n">LED</span><span class="p">{</span>
  <span class="kt">uint8_t</span> <span class="n">pin</span><span class="p">;</span>    <span class="c1">// connected pin</span>
  <span class="kt">uint8_t</span> <span class="n">brightness</span><span class="p">;</span> <span class="c1">// LED power (roughly maps to brightness)</span>
  <span class="kt">uint8_t</span> <span class="n">max_brightness</span><span class="p">;</span> <span class="c1">//Maximum allowed brightness</span>
  <span class="n">bool</span> <span class="n">increasing</span><span class="p">;</span><span class="c1">// Whether the LED is increasing in power</span>
<span class="p">};</span>

<span class="c1">// Represents the state of a single button</span>
<span class="k">struct</span> <span class="n">button</span><span class="p">{</span>
  <span class="kt">uint8_t</span> <span class="n">pin</span><span class="p">;</span>    <span class="c1">// connected pin</span>
  <span class="n">bool</span> <span class="n">pressed</span><span class="p">;</span>   <span class="c1">// whether the button was pressed in the last program cycle</span>
<span class="p">};</span>

<span class="c1">// Bookkeeping array of LED structs, the state of all LEDs</span>
<span class="k">struct</span> <span class="n">LED</span> <span class="n">LEDs</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{{</span><span class="n">B1_PIN</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="nb">false</span><span class="p">},</span> <span class="p">{</span><span class="n">B2_PIN</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="nb">false</span><span class="p">},</span>
                     <span class="p">{</span><span class="n">COLOR_R_PIN</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="nb">false</span><span class="p">},</span> <span class="p">{</span><span class="n">COLOR_G_PIN</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="nb">false</span><span class="p">},</span>
                     <span class="p">{</span><span class="n">COLOR_B_PIN</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="nb">false</span><span class="p">}};</span>   <span class="c1">// All LEDs are initially off</span>

<span class="c1">// Bookkeeping array of button structs. Contains state for all buttons</span>
<span class="k">struct</span> <span class="n">button</span> <span class="n">buttons</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{{</span><span class="n">BTN1_PIN</span><span class="p">,</span> <span class="nb">false</span><span class="p">},</span> <span class="p">{</span><span class="n">BTN2_PIN</span><span class="p">,</span> <span class="nb">false</span><span class="p">},</span> <span class="p">{</span><span class="n">BTN3_PIN</span><span class="p">,</span> <span class="nb">false</span><span class="p">}};</span>

<span class="c1">// Pointer used to reference each LED struct (saves copying)</span>
<span class="k">struct</span> <span class="n">LED</span><span class="o">*</span> <span class="n">led_ptr</span><span class="p">;</span>
<span class="c1">// Pointer used to reference each button struct (saves copying)</span>
<span class="k">struct</span> <span class="n">button</span><span class="o">*</span> <span class="n">btn</span><span class="p">;</span>


<span class="c1">// Helper function</span>
<span class="c1">// Declare brightness control function header</span>
<span class="kt">void</span> <span class="nf">brightness_control</span><span class="p">(</span><span class="k">struct</span> <span class="n">LED</span><span class="o">*</span> <span class="n">l</span><span class="p">,</span> <span class="k">struct</span> <span class="n">button</span><span class="o">*</span> <span class="n">b</span><span class="p">);</span>


<span class="c1">// "Main" functions</span>
<span class="c1">// Setup code (run once @ startup)</span>
<span class="kt">void</span> <span class="nf">setup</span><span class="p">(){</span>  
  <span class="c1">// Loop through every button pin &amp; set to input mode</span>
  <span class="k">for</span><span class="p">(</span><span class="n">btn</span> <span class="o">=</span> <span class="n">buttons</span><span class="p">;</span> <span class="n">btn</span> <span class="o">&lt;</span> <span class="n">buttons</span> <span class="o">+</span> <span class="n">NUM_BTNS</span><span class="p">;</span> <span class="o">++</span><span class="n">btn</span><span class="p">)</span>
    <span class="n">pinMode</span><span class="p">(</span><span class="n">btn</span><span class="o">-&gt;</span><span class="n">pin</span><span class="p">,</span> <span class="n">INPUT</span><span class="p">);</span>    <span class="c1">// Set a single button pin to input mode</span>
  
<span class="p">}</span>


<span class="c1">// Infinite loop (Interactive program goes here)</span>
<span class="kt">void</span> <span class="nf">loop</span><span class="p">(){</span>
  <span class="c1">// Calls brightness control helper function on blue LEDs &amp; their matching buttons</span>
  <span class="n">brightness_control</span><span class="p">(</span><span class="n">LEDs</span><span class="p">,</span> <span class="n">buttons</span><span class="p">);</span>    <span class="c1">// Top blue LED</span>
  <span class="n">brightness_control</span><span class="p">(</span><span class="n">LEDs</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">buttons</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span><span class="c1">// Bottom blue LED</span>
  
  <span class="c1">// Test if the bottom button for controlling the RGB LED is pressed</span>
  <span class="k">if</span><span class="p">(</span><span class="n">digitalRead</span><span class="p">(</span><span class="n">buttons</span><span class="p">[</span><span class="mi">2</span><span class="p">].</span><span class="n">pin</span><span class="p">)){</span>  <span class="c1">// If button is pressed, only set button state to true</span>
    <span class="n">buttons</span><span class="p">[</span><span class="mi">2</span><span class="p">].</span><span class="n">pressed</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>  <span class="c1">// Set button as pressed</span>
  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">buttons</span><span class="p">[</span><span class="mi">2</span><span class="p">].</span><span class="n">pressed</span><span class="p">){</span>  <span class="c1">// If button was just released</span>
    <span class="n">buttons</span><span class="p">[</span><span class="mi">2</span><span class="p">].</span><span class="n">pressed</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span> <span class="c1">// Set button state to false (only take this branch once per button click)</span>
    <span class="k">for</span><span class="p">(</span><span class="n">led_ptr</span> <span class="o">=</span> <span class="n">LEDs</span><span class="o">+</span><span class="mi">2</span><span class="p">;</span> <span class="n">led_ptr</span> <span class="o">&lt;</span> <span class="n">LEDs</span><span class="o">+</span><span class="n">NUM_LEDS</span><span class="p">;</span> <span class="o">++</span><span class="n">led_ptr</span><span class="p">){</span>  <span class="c1">// Shifts power level to all three primary color LEDs </span>
      <span class="k">if</span><span class="p">(</span><span class="n">led_ptr</span><span class="o">-&gt;</span><span class="n">increasing</span><span class="p">){</span>  <span class="c1">// If the LED is set to increasing power</span>
        <span class="n">led_ptr</span><span class="o">-&gt;</span><span class="n">brightness</span> <span class="o">+=</span> <span class="n">random</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">);</span>  <span class="c1">// Randomly increase pwoer between 3 &amp; 6</span>
      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>  <span class="c1">// otherwise decrease power</span>
        <span class="n">led_ptr</span><span class="o">-&gt;</span><span class="n">brightness</span> <span class="o">-=</span> <span class="n">random</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">);</span>  <span class="c1">// Randomly decrease power between 3 &amp; 6</span>
      <span class="p">}</span>
      <span class="c1">// Constrain power level within a set range</span>
      <span class="n">led_ptr</span><span class="o">-&gt;</span><span class="n">brightness</span> <span class="o">=</span> <span class="n">constrain</span><span class="p">(</span><span class="n">led_ptr</span><span class="o">-&gt;</span><span class="n">brightness</span><span class="p">,</span> <span class="n">ANALOG_MIN</span><span class="p">,</span> <span class="n">led_ptr</span><span class="o">-&gt;</span><span class="n">max_brightness</span><span class="p">);</span>
      <span class="c1">// 25% chance of switching between increasing/decreasing power</span>
      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">random</span><span class="p">(</span><span class="mi">4</span><span class="p">)){</span>
        <span class="n">led_ptr</span><span class="o">-&gt;</span><span class="n">increasing</span> <span class="o">=</span> <span class="o">!</span><span class="n">led_ptr</span><span class="o">-&gt;</span><span class="n">increasing</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>
    
  <span class="p">}</span>

  <span class="c1">// Write updated brightness value to each LED</span>
  <span class="k">for</span><span class="p">(</span><span class="n">led_ptr</span> <span class="o">=</span> <span class="n">LEDs</span><span class="p">;</span> <span class="n">led_ptr</span> <span class="o">&lt;</span> <span class="n">LEDs</span> <span class="o">+</span> <span class="n">NUM_LEDS</span><span class="p">;</span> <span class="o">++</span><span class="n">led_ptr</span><span class="p">)</span>
    <span class="n">analogWrite</span><span class="p">(</span><span class="n">led_ptr</span><span class="o">-&gt;</span><span class="n">pin</span><span class="p">,</span> <span class="n">led_ptr</span><span class="o">-&gt;</span><span class="n">brightness</span><span class="p">);</span>  <span class="c1">// Write the state of single LED from bookkeeping data structure</span>
  
  <span class="n">delay</span><span class="p">(</span><span class="mi">250</span><span class="p">);</span>   <span class="c1">// Waits 250 ms</span>
<span class="p">}</span>

<span class="cm">/**
 * Control the power (~= brightness) to a given LED, optionally uses the duration of button press to
 * adjust the max brightness &amp; period of fading LED
 * 
 * @param l Pointer to LED being controlled by user
 * @param b Pointer to button used to program LED max brightness &amp; duration of each fade cycle
*/</span>
<span class="kt">void</span> <span class="nf">brightness_control</span><span class="p">(</span><span class="k">struct</span> <span class="n">LED</span><span class="o">*</span> <span class="n">l</span><span class="p">,</span> <span class="k">struct</span> <span class="n">button</span><span class="o">*</span> <span class="n">b</span><span class="p">){</span>
  <span class="k">if</span><span class="p">(</span><span class="n">digitalRead</span><span class="p">(</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">pin</span><span class="p">)){</span>  <span class="c1">//  Check if the button is currently pressed</span>
    <span class="k">if</span><span class="p">(</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">pressed</span><span class="p">){</span> <span class="c1">// If the button was pressed in the last program cycle</span>
      <span class="n">l</span><span class="o">-&gt;</span><span class="n">max_brightness</span><span class="o">++</span><span class="p">;</span>  <span class="c1">// Continue to increment power</span>
      <span class="n">l</span><span class="o">-&gt;</span><span class="n">max_brightness</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">l</span><span class="o">-&gt;</span><span class="n">max_brightness</span><span class="p">,</span> <span class="n">ANALOG_MAX</span><span class="p">);</span> <span class="c1">// Prevent int overflow</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>  <span class="c1">// Button NOT pressed in the last cycle</span>
      <span class="n">b</span><span class="o">-&gt;</span><span class="n">pressed</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>    <span class="c1">// Update current button state</span>
      <span class="n">l</span><span class="o">-&gt;</span><span class="n">brightness</span> <span class="o">=</span> <span class="n">l</span><span class="o">-&gt;</span><span class="n">max_brightness</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  <span class="c1">// reset brightness to zero</span>
      <span class="n">l</span><span class="o">-&gt;</span><span class="n">increasing</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>  <span class="c1">// Special value to ensure the LED brightness change direction is correct</span>
    <span class="p">}</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>  <span class="c1">// Button is not currently pressed</span>
    <span class="n">b</span><span class="o">-&gt;</span><span class="n">pressed</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span> <span class="c1">// Update button state</span>
  <span class="p">}</span>
  
  <span class="c1">// Change direction of shifting brightness if we hit max/min allowed brightness for the given LED</span>
  <span class="k">if</span> <span class="err">\</span><span class="p">(</span><span class="n">l</span><span class="o">-&gt;</span><span class="n">brightness</span> <span class="o">==</span> <span class="n">l</span><span class="o">-&gt;</span><span class="n">max</span><span class="err">\</span><span class="n">_brightness</span> <span class="err">\</span><span class="o">||</span> <span class="n">l</span><span class="o">-&gt;</span><span class="n">brightness</span> <span class="o">==</span> <span class="n">ANALOG</span><span class="err">\</span><span class="n">_MIN</span><span class="p">)</span>
    <span class="n">l</span><span class="o">-&gt;</span><span class="n">increasing</span> <span class="o">=</span> <span class="o">!</span><span class="n">l</span><span class="o">-&gt;</span><span class="n">increasing</span><span class="p">;</span> <span class="c1">// Flip direction</span>
  
  <span class="c1">// Increment/decrement power (brightness) value as needed</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">l</span><span class="o">-&gt;</span><span class="n">increasing</span><span class="p">){</span>
    <span class="n">l</span><span class="o">-&gt;</span><span class="n">brightness</span><span class="o">++</span><span class="p">;</span>  <span class="c1">// Increasing power</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="n">l</span><span class="o">-&gt;</span><span class="n">brightness</span><span class="o">--</span><span class="p">;</span>  <span class="c1">// Decreasing power</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure>]]></content><author><name></name></author><category term="jekyll" /><category term="update" /><summary type="html"><![CDATA[Demo]]></summary></entry><entry><title type="html">Assignment 1: Blink!</title><link href="http://localhost:4000/hcde439/jekyll/update/2023/01/14/Assignment-1-Blink.html" rel="alternate" type="text/html" title="Assignment 1: Blink!" /><published>2023-01-14T22:13:07-08:00</published><updated>2023-01-14T22:13:07-08:00</updated><id>http://localhost:4000/hcde439/jekyll/update/2023/01/14/Assignment%201:%20Blink</id><content type="html" xml:base="http://localhost:4000/hcde439/jekyll/update/2023/01/14/Assignment-1-Blink.html"><![CDATA[<h2 id="demo">Demo</h2>
<p><img src="/hcde439/assets/hw1_demo.gif" alt="Demo video for 3 LEDs blinking randomly" width="75%" /></p>

<p>Demo showing 3 LEDs connected to an Arudino microcontroller blinking randomly.</p>

<h2 id="circuit-drawing">Circuit drawing</h2>
<p><img src="/hcde439/assets/hw1_circuit.png" alt="Circuit drawing" width="80%" /></p>

<p>The circuit is is powered via USB connected to the Arudino microcontroller. The red, green, and blue LEDs are connected to pin 2, 3, and 4 respectively. Each LED is connected in series with a resistor to reduce the current through the LED.</p>

<p><img src="/hcde439/assets/hw1_circuit_photo.jpeg" alt="Circuit photo" width="80%" /></p>

<h2 id="calculating-resistor-values">Calculating resistor values</h2>
<p>Because each LED used in this assignment can operate safely with $\leq 30 \text{mA}$ of current, we need to use resisters to reduce the amount of current going through each LED.</p>

<p>Since we are connecting the resister &amp; the LED in series, the amount of current through the LED is the same as that for the resister ($I_\text{L} = I_\text{r}$). This also means that the sum of voltage drop across the resister and LED should be equal to the voltage provided by the Arduino microcontroller (5V).</p>

<p>With these information, we calculate the minimum resistance by applying Ohm’s law on the resister.
$$
\begin{align*}
  V_\text{r} &amp;= I_\text{r} R_\text{r} &amp;&amp; \text{Ohm’s law}\cr
  V_\text{PSU} - V_\text{L} &amp;= I_\text{L} R_\text{r} &amp;&amp;\text{Substitute resister V &amp; I}\cr
  5\texttt{V} - V_\text{L} &amp;= 20\texttt{mA} \cdot R_\text{r}\cr
\end{align*}
$$</p>

<p>A <strong>220 Ω</strong> resister is used for red and green LEDs because these LEDs have a voltage drop of 1.7V. Their resisters’ resistance to be at least
$$
\begin{align*}
  V&amp;=IR\cr
  5\;\texttt{V} - 1.7\;\texttt{V} &amp;=20\;\texttt{mA} \cdot \textrm{R}\cr
  \frac{3.3\;\texttt{V}}{0.02\;\texttt{A}} &amp;= \textrm{R}\cr
  \textrm{R} &amp;= 165 \;\Omega
\end{align*}
$$</p>

<p>A <strong>100 Ω</strong> resister is used for the blue LED (voltage drop = 3.3V). It needs an resistor that is at least
$$
\begin{align*}
    V&amp;=IR\cr
    5\;\texttt{V} - 3.3\;\texttt{V} &amp;=20\;\texttt{mA} \cdot \textrm{R}\cr
    \frac{1.7\;\texttt{V}}{0.02\;\texttt{A}} &amp;= \textrm{R}\cr
    \textrm{R} &amp;= 85 \;\Omega
\end{align*}
$$</p>

<h2 id="arduino-code">Arduino code</h2>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="c1">// Preprocessor macros for LED -&gt; pin mapping &amp; No. of LEDs</span>
<span class="cp">#define RED_PIN 2
#define GREEN_PIN 3
#define BLUE_PIN 4
#define NUM_LEDS 3
</span>
<span class="c1">// Array of LEDs by their pin</span>
<span class="kt">int</span> <span class="n">led_pins</span><span class="p">[</span><span class="n">NUM_LEDS</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="n">RED_PIN</span><span class="p">,</span> <span class="n">GREEN_PIN</span><span class="p">,</span> <span class="n">BLUE_PIN</span><span class="p">};</span>
<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>  <span class="c1">// Loop variable</span>

<span class="kt">void</span> <span class="nf">setup</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// Set all used pins to output mode</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NUM_LEDS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>  <span class="c1">// Loop through every LED</span>
    <span class="n">pinMode</span><span class="p">(</span><span class="n">led_pins</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">OUTPUT</span><span class="p">);</span> <span class="c1">// set a single pin to output</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">loop</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// Modify the state of every connected LED (might remain the same)</span>
  <span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NUM_LEDS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>  <span class="c1">// Loop through every LED</span>
    <span class="n">digitalWrite</span><span class="p">(</span><span class="n">led_pins</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">random</span><span class="p">(</span><span class="mi">2</span><span class="p">));</span> <span class="c1">// Randomly decide if this LED is on or off</span>
  <span class="p">}</span>
  <span class="n">delay</span><span class="p">(</span><span class="n">random</span><span class="p">(</span><span class="mi">500</span><span class="p">,</span> <span class="mi">1500</span><span class="p">));</span> <span class="c1">// Random delay between 500 and 1500 ms</span>
<span class="p">}</span></code></pre></figure>]]></content><author><name></name></author><category term="jekyll" /><category term="update" /><summary type="html"><![CDATA[Demo]]></summary></entry></feed>